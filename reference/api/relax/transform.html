





<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tvm.relax.transform &mdash; Apache TVM Unity 0.14.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/tabs.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/tlcpack_theme.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/tvm-logo-square.png"/>
  

  
  
  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <script type="text/javascript" src="../../../_static/js/tlcpack_theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="tvm.rpc" href="../rpc.html" />
    <link rel="prev" title="tvm.relax.op" href="op.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    
<header class="header">
    <div class="innercontainer">
      <div class="headerInner d-flex justify-content-between align-items-center">
          <div class="headerLogo">
          </div>

          <div id="headMenu" class="headerNav">
            <button type="button" id="closeHeadMenu" class="navCloseBtn"><img src="../../../_static/img/close-icon.svg" alt="Close"></button>
             <ul class="nav">
                <li class="nav-item">
                   <a class="nav-link" href=https://github.com/apache/tvm/tree/unity/>Github</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://mlc.ai/mlc-llm/>MLC-LLM</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://mlc.ai/>MLC-Tutorial</a>
                </li>
             </ul>
               <div class="responsivetlcdropdown">
                 <button type="button" class="btn-link">
                   ASF
                 </button>
                 <ul>
                     <li>
                       <a href=https://apache.org/>Apache Homepage</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/licenses/>License</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/security/>Security</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/thanks.html>Thanks</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/events/current-event>Events</a>
                     </li>
                 </ul>
               </div>
          </div>
            <div class="responsiveMenuIcon">
              <button type="button" id="menuBtn" class="btn-menu"><img src="../../../_static/img/menu-icon.svg" alt="Menu Icon"></button>
            </div>

            <div class="tlcDropdown">
              <div class="dropdown">
                <button type="button" class="btn-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  ASF
                </button>
                <div class="dropdown-menu dropdown-menu-right">
                  <ul>
                     <li>
                       <a href=https://apache.org/>Apache Homepage</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/licenses/>License</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/security/>Security</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/thanks.html>Thanks</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/events/current-event>Events</a>
                     </li>
                  </ul>
                </div>
              </div>
          </div>
       </div>
    </div>
 </header>
 
    <nav data-toggle="wy-nav-shift" class="wy-nav-side fixed">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
                <div class="version">
                  0.14.dev0
                </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/install.html">Installing Apache TVM Unity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/tutorials/quick_start.html">Quick Start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deep Dive</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../deep_dive/tensor_ir/index.html">TensorIR</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../error.html">tvm.error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ir.html">tvm.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../instrument.html">tvm.instrument</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform.html">tvm.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">tvm.target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/runtime.html">tvm.runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/ndarray.html">tvm.runtime.ndarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/relax_vm.html">tvm.runtime.relax_vm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/disco.html">tvm.runtime.disco</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/profiling.html">tvm.runtime.profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../te.html">tvm.te</a></li>
<li class="toctree-l2"><a class="reference internal" href="../topi.html">tvm.topi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/tir.html">tvm.tir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/analysis.html">tvm.tir.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/schedule.html">tvm.tir.schedule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/stmt_functor.html">tvm.tir.stmt_functor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/transform.html">tvm.tir.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../meta_schedule.html">tvm.meta_schedule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dlight.html">tvm.dlight</a></li>
<li class="toctree-l2"><a class="reference internal" href="relax.html">tvm.relax</a></li>
<li class="toctree-l2"><a class="reference internal" href="analysis.html">tvm.relax.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="block_builder.html">tvm.relax.block_builder</a></li>
<li class="toctree-l2"><a class="reference internal" href="frontend.html">tvm.relax.frontend</a></li>
<li class="toctree-l2"><a class="reference internal" href="op.html">tvm.relax.op</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">tvm.relax.transform</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.AllocateWorkspace"><code class="docutils literal notranslate"><span class="pre">AllocateWorkspace()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.AlterOpImpl"><code class="docutils literal notranslate"><span class="pre">AlterOpImpl()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.AnnotateTIROpPattern"><code class="docutils literal notranslate"><span class="pre">AnnotateTIROpPattern()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.AttachGlobalSymbol"><code class="docutils literal notranslate"><span class="pre">AttachGlobalSymbol()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.BindParams"><code class="docutils literal notranslate"><span class="pre">BindParams()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.BindSymbolicVars"><code class="docutils literal notranslate"><span class="pre">BindSymbolicVars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.BundleModelParams"><code class="docutils literal notranslate"><span class="pre">BundleModelParams()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.CallTIRRewrite"><code class="docutils literal notranslate"><span class="pre">CallTIRRewrite()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.CanonicalizeBindings"><code class="docutils literal notranslate"><span class="pre">CanonicalizeBindings()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.CombineParallelMatmul"><code class="docutils literal notranslate"><span class="pre">CombineParallelMatmul()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.ConvertLayout"><code class="docutils literal notranslate"><span class="pre">ConvertLayout()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.DFPattern"><code class="docutils literal notranslate"><span class="pre">DFPattern</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.dup"><code class="docutils literal notranslate"><span class="pre">DFPattern.dup()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.extract_matched_expr"><code class="docutils literal notranslate"><span class="pre">DFPattern.extract_matched_expr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.fork_to"><code class="docutils literal notranslate"><span class="pre">DFPattern.fork_to()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.has_attr"><code class="docutils literal notranslate"><span class="pre">DFPattern.has_attr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.has_dtype"><code class="docutils literal notranslate"><span class="pre">DFPattern.has_dtype()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.has_shape"><code class="docutils literal notranslate"><span class="pre">DFPattern.has_shape()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.has_type"><code class="docutils literal notranslate"><span class="pre">DFPattern.has_type()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.match"><code class="docutils literal notranslate"><span class="pre">DFPattern.match()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.only_used_by"><code class="docutils literal notranslate"><span class="pre">DFPattern.only_used_by()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.same_shape_as"><code class="docutils literal notranslate"><span class="pre">DFPattern.same_shape_as()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.DFPattern.used_by"><code class="docutils literal notranslate"><span class="pre">DFPattern.used_by()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.DataflowBlockPass"><code class="docutils literal notranslate"><span class="pre">DataflowBlockPass</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.DeadCodeElimination"><code class="docutils literal notranslate"><span class="pre">DeadCodeElimination()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.DecomposeOpsForInference"><code class="docutils literal notranslate"><span class="pre">DecomposeOpsForInference()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.DecomposeOpsForTraining"><code class="docutils literal notranslate"><span class="pre">DecomposeOpsForTraining()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.EliminateCommonSubexpr"><code class="docutils literal notranslate"><span class="pre">EliminateCommonSubexpr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.Expr"><code class="docutils literal notranslate"><span class="pre">Expr</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FewShotTuning"><code class="docutils literal notranslate"><span class="pre">FewShotTuning()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FoldConstant"><code class="docutils literal notranslate"><span class="pre">FoldConstant()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FoldDataflowBlockOutput"><code class="docutils literal notranslate"><span class="pre">FoldDataflowBlockOutput()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FunctionPass"><code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FuseOps"><code class="docutils literal notranslate"><span class="pre">FuseOps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FuseOpsByPattern"><code class="docutils literal notranslate"><span class="pre">FuseOpsByPattern()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FuseTIR"><code class="docutils literal notranslate"><span class="pre">FuseTIR()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.FusionPattern"><code class="docutils literal notranslate"><span class="pre">FusionPattern</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.Gradient"><code class="docutils literal notranslate"><span class="pre">Gradient()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.IndexMap"><code class="docutils literal notranslate"><span class="pre">IndexMap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.from_func"><code class="docutils literal notranslate"><span class="pre">IndexMap.from_func()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.from_func_with_separators"><code class="docutils literal notranslate"><span class="pre">IndexMap.from_func_with_separators()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.inverse"><code class="docutils literal notranslate"><span class="pre">IndexMap.inverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.is_equivalent_to"><code class="docutils literal notranslate"><span class="pre">IndexMap.is_equivalent_to()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.map_indices"><code class="docutils literal notranslate"><span class="pre">IndexMap.map_indices()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.map_ndarray"><code class="docutils literal notranslate"><span class="pre">IndexMap.map_ndarray()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.map_shape"><code class="docutils literal notranslate"><span class="pre">IndexMap.map_shape()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.IndexMap.non_surjective_inverse"><code class="docutils literal notranslate"><span class="pre">IndexMap.non_surjective_inverse()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.LambdaLift"><code class="docutils literal notranslate"><span class="pre">LambdaLift()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.LazyTransformParams"><code class="docutils literal notranslate"><span class="pre">LazyTransformParams</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.LegalizeOps"><code class="docutils literal notranslate"><span class="pre">LegalizeOps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.LiftTransformParams"><code class="docutils literal notranslate"><span class="pre">LiftTransformParams()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.MergeCompositeFunctions"><code class="docutils literal notranslate"><span class="pre">MergeCompositeFunctions()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.MetaScheduleApplyDatabase"><code class="docutils literal notranslate"><span class="pre">MetaScheduleApplyDatabase()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.MetaScheduleTuneIRMod"><code class="docutils literal notranslate"><span class="pre">MetaScheduleTuneIRMod()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.MetaScheduleTuneTIR"><code class="docutils literal notranslate"><span class="pre">MetaScheduleTuneTIR()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.NDArray"><code class="docutils literal notranslate"><span class="pre">NDArray</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.NDArray.asnumpy"><code class="docutils literal notranslate"><span class="pre">NDArray.asnumpy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.NDArray.copyfrom"><code class="docutils literal notranslate"><span class="pre">NDArray.copyfrom()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.NDArray.copyto"><code class="docutils literal notranslate"><span class="pre">NDArray.copyto()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.NDArray.device"><code class="docutils literal notranslate"><span class="pre">NDArray.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.NDArray.dtype"><code class="docutils literal notranslate"><span class="pre">NDArray.dtype</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.NDArray.numpy"><code class="docutils literal notranslate"><span class="pre">NDArray.numpy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.NDArray.same_as"><code class="docutils literal notranslate"><span class="pre">NDArray.same_as()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.Normalize"><code class="docutils literal notranslate"><span class="pre">Normalize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.Object"><code class="docutils literal notranslate"><span class="pre">Object</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.OptimizeLayoutTransform"><code class="docutils literal notranslate"><span class="pre">OptimizeLayoutTransform</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.PatternCheckContext"><code class="docutils literal notranslate"><span class="pre">PatternCheckContext</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.PrimFunc"><code class="docutils literal notranslate"><span class="pre">PrimFunc</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.PrimFunc.specialize"><code class="docutils literal notranslate"><span class="pre">PrimFunc.specialize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.PrimFunc.with_body"><code class="docutils literal notranslate"><span class="pre">PrimFunc.with_body()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.RealizeVDevice"><code class="docutils literal notranslate"><span class="pre">RealizeVDevice()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.RemovePurityChecking"><code class="docutils literal notranslate"><span class="pre">RemovePurityChecking()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.RewriteCUDAGraph"><code class="docutils literal notranslate"><span class="pre">RewriteCUDAGraph()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.RewriteDataflowReshape"><code class="docutils literal notranslate"><span class="pre">RewriteDataflowReshape()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.RunCodegen"><code class="docutils literal notranslate"><span class="pre">RunCodegen()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.SplitCallTIRByPattern"><code class="docutils literal notranslate"><span class="pre">SplitCallTIRByPattern()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.StaticPlanBlockMemory"><code class="docutils literal notranslate"><span class="pre">StaticPlanBlockMemory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.ToMixedPrecision"><code class="docutils literal notranslate"><span class="pre">ToMixedPrecision()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.ToNonDataflow"><code class="docutils literal notranslate"><span class="pre">ToNonDataflow()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.UpdateVDevice"><code class="docutils literal notranslate"><span class="pre">UpdateVDevice()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.VMBuiltinLower"><code class="docutils literal notranslate"><span class="pre">VMBuiltinLower()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.VMShapeLower"><code class="docutils literal notranslate"><span class="pre">VMShapeLower()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.Var"><code class="docutils literal notranslate"><span class="pre">Var</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.transform.Var.name_hint"><code class="docutils literal notranslate"><span class="pre">Var.name_hint</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.dataflowblock_pass"><code class="docutils literal notranslate"><span class="pre">dataflowblock_pass()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.transform.function_pass"><code class="docutils literal notranslate"><span class="pre">function_pass()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../rpc.html">tvm.rpc</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      
      <nav class="wy-nav-top" aria-label="top navigation" data-toggle="wy-nav-top">
        
            <div class="togglemenu">

            </div>
            <div class="nav-content">
              <!-- Apache TVM Unity -->
              Table of Contents
            </div>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        

          




















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> <span class="br-arrow">></span></li>
        
          <li><a href="../index.html">API Reference</a> <span class="br-arrow">></span></li>
        
      <li>tvm.relax.transform</li>
    
    
      
      
        
      
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/mlc-ai/docs/edit/main/docs/reference/api/relax/transform.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="module-tvm.relax.transform">
<span id="tvm-relax-transform"></span><h1>tvm.relax.transform<a class="headerlink" href="#module-tvm.relax.transform" title="Permalink to this heading">¶</a></h1>
<p>Relax transformations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.AllocateWorkspace">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">AllocateWorkspace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.AllocateWorkspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a workspace, represented by a tensor of size big enough for all external
functions that require a temporary storage, and append it to the arguments of external
functions.</p>
<p>An external function can specify its workspace requirement by the kWorkspaceSize attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for allocating workspace.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.AlterOpImpl">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">AlterOpImpl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op_impl_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.PrimFunc" title="tvm.tir.function.PrimFunc"><span class="pre">PrimFunc</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_buffer_transforms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_buffer_axis_separators</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">axis_separator</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.AlterOpImpl" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all PrimFunc’s which have matching ‘operator_name’ attribute, with replacement
PrimFunc that could possibly have different layouts on i/o buffers. The layout
transformations on i/o buffers is present in the op_buffer_transforms map. Inserts the layout
transformations in the call sites of PrimFuncs being replaced to transform i/o
tensors into expected layout by new PrimFunc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op_impl_map</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#tvm.relax.transform.PrimFunc" title="tvm.relax.transform.PrimFunc"><em>PrimFunc</em></a><em>]</em>) – op_kind to PrimFunc map</p></li>
<li><p><strong>op_buffer_transforms</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap"><em>IndexMap</em></a><em>, </em><em>Callable</em><em>]</em><em>]</em>) – op_kind to layout transformation map for each of the buffers</p></li>
<li><p><strong>op_buffer_axis_separators</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>List</em><em>[</em><em>Union</em><em>[</em><em>IndexMap.AXIS_SEPARATOR</em><em>, </em><em>Callable</em><em>]</em><em>]</em><em>]</em>) – op_kind to axis_separator for each index_map</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.AnnotateTIROpPattern">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">AnnotateTIROpPattern</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.AnnotateTIROpPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate Op Pattern Kind for TIR functions</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.AttachGlobalSymbol">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">AttachGlobalSymbol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.AttachGlobalSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach global_symbol to Relax functions and TIR Primfuncs for codegen.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.BindParams">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">BindParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../runtime/ndarray.html#tvm.runtime.ndarray.NDArray" title="tvm.runtime.ndarray.NDArray"><span class="pre">NDArray</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.BindParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind params of function of the module to constant tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func_name</strong> (<em>str</em>) – The function name to be bound</p></li>
<li><p><strong>params</strong> (<em>Dict</em><em>[</em>) – <dl>
<dt>Union[str,relax.Var],</dt><dd><blockquote>
<div><p>Union[tvm.runtime.NDArray, np.ndarray],</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>The map from parameter or parameter name name to constant
tensors.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.BindSymbolicVars">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">BindSymbolicVars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binding_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.BindSymbolicVars" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind params of function of the module to constant tensors.
:param binding_map: The map from symbolic varname to integer.
:type binding_map: Mapping[Union[str, tvm.tir.Var], tvm.tir.PrimExpr]
:param func_name: The function name to be bound.  If None (default), all</p>
<blockquote>
<div><p>functions within the module will be updated.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.BundleModelParams">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">BundleModelParams</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.BundleModelParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bundle several model parameters into a single tuple paramters</p>
<p>For each function, if the function has the attribute “num_input”,
separate between run-time parameters and compile-time weights.
Run-time parameters (e.g. activations) are the first <cite>num_input</cite>
parameters, and the remainder are compile-time weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for lifting transformation of parameters.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.CallTIRRewrite">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">CallTIRRewrite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.CallTIRRewrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform explicit tensor allocation for call_tir and call_dps_packed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.CanonicalizeBindings">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">CanonicalizeBindings</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.CanonicalizeBindings" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalizes variable definitions
(e.g., if there is y = x and z = y, it replaces uses of y and z with x).</p>
<p>Best combined with constant folding and the elimination of unused definitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.CombineParallelMatmul">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">CombineParallelMatmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.CombineParallelMatmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine multiple matmul operators sharing the same LHS matrix into one,
followed by slicing. When all matmul branches in a tree have the same set of fused ops,
the fused ops are applied to the combined matmul output before slicing.</p>
<p>Currently, only a limited set of fused ops is supported. It includes bias add,
relu, gelu, gelu_tanh and silu activation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>check</strong> (<em>Callable</em><em>[</em><em>[</em><em>relax.Var</em><em>, </em><em>List</em><em>[</em><em>relax.Var</em><em>]</em><em>, </em><em>List</em><em>[</em><em>relax.Var</em><em>]</em><em>, </em><em>Dict</em><em>[</em><em>relax.Var</em><em>, </em><em>Expr</em><em>]</em><em>]</em><em>, </em><em>bool</em><em>]</em>) – A function to filter out unwanted branches, with the signature
(input, [rhs], [bias], binding) -&gt; bool.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The corresponding pass.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.ConvertLayout">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">ConvertLayout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">desired_layouts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.ConvertLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatic layout conversion pass.
:param desired_layouts: The desired layout of conv2d ops is a map from the name of the op to the desired layout</p>
<blockquote>
<div><p>of the desired feature map, weight and output. For example, if we want to convert the
layout of conv2d from NCHW to NHWC, we can set the desired layout of conv2d to be
{“relax.nn.conv2d”: [“NHWC”, “OHWI”]}.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for layout conversion.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">DFPattern</span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class of all Patterns.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.dup">
<span class="sig-name descname"><span class="pre">dup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.dpl.pattern.DFPattern"><span class="pre">DFPattern</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate the current pattern (new object under different address)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A duplicated pattern</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern">DFPattern</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.extract_matched_expr">
<span class="sig-name descname"><span class="pre">extract_matched_expr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2val</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.dpl.pattern.DFPattern"><span class="pre">DFPattern</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.extract_matched_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Match a relax.Expr and return a map from matching patterns to matched expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>tvm.relax.Expr</em>) – The expression to match</p></li>
<li><p><strong>var2val</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>tvm.relax.Var</em><em>, </em><em>tvm.relax.Expr</em><em>]</em><em>]</em>) – A mapping from relax.Var to relax.Expr for autojump.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – Map from matching patterns to matched expressions.
Return None if the pattern does not match expr.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Optional[Dict[<a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern">DFPattern</a>, Expr]]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Check the note of <cite>match</cite> for the meaning of var2val.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.fork_to">
<span class="sig-name descname"><span class="pre">fork_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.fork_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Fork the current pattern to multiple pattern branches</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.has_attr">
<span class="sig-name descname"><span class="pre">has_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../runtime/runtime.html#tvm.runtime.Object" title="tvm.runtime.object.Object"><span class="pre">Object</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">AttrPattern</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.has_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an attribute constraint to this pattern</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>attrs</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#tvm.relax.transform.Object" title="tvm.relax.transform.Object"><em>Object</em></a><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The resulting AttrPattern</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>AttrPattern</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.has_dtype">
<span class="sig-name descname"><span class="pre">has_dtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataTypePattern</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.has_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a type constraint to this pattern</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>str</em>) – The dtype to match</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The resulting DataTypePattern</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>DataTypePattern</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.has_shape">
<span class="sig-name descname"><span class="pre">has_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ShapePattern</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.has_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a shape constraint to this pattern</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – Expected shape list</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The resulting ShapePattern</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ShapePattern</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>has_shape assumes that the matched relax.Expr only has one
output tensor. Use is_tuple for those with multiple outputs.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.has_type">
<span class="sig-name descname"><span class="pre">has_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ttype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="analysis.html#tvm.relax.analysis.Type" title="tvm.ir.type.Type"><span class="pre">Type</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TypePattern</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.has_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a type constraint to this pattern</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ttype</strong> (<a class="reference internal" href="analysis.html#tvm.relax.analysis.Type" title="tvm.ir.type.Type"><em>tvm.ir.type.Type</em></a>) – The type to match</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The resulting TypePattern</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TypePattern</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2val</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match a relax.Expr syntactically</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>tvm.relax.Expr</em>) – The expression to match</p></li>
<li><p><strong>var2val</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>tvm.relax.Var</em><em>, </em><em>tvm.relax.Expr</em><em>]</em><em>]</em>) – A mapping from relax.Var to relax.Expr for autojump.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – Whether or not the expression matches the pattern</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike Relay whose function is an expression, functions in Relax consist
of blocks of bindings that are not syntactically connected. We use a
mapping (i.e., var2val) to mitigate the gap. For example, when matching
“relax.add(lv0, lv1)”, given var2val, we match lv0’s bound expression
when the recursive pattern matching goes to check lv0. The var2val mapping
can be computed through the tvm.relax.analysis.get_var2val function.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.only_used_by">
<span class="sig-name descname"><span class="pre">only_used_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.dpl.pattern.DFPattern"><span class="pre">DFPattern</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">PatternSeq</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">PatternSeq</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.only_used_by" title="Permalink to this definition">¶</a></dt>
<dd><p>The current pattern being <strong>ONLY</strong> used by another pattern (sequence)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern"><em>DFPattern</em></a><em>, </em><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern"><em>DFPattern</em></a><em>]</em>) – The consumer pattern (sequence)</p></li>
<li><p><strong>index</strong> (<em>int</em><em>, </em><em>optional</em>) – The argument index called by the consumer pattern, by default -1</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – A chained pattern sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PatternSeq</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.same_shape_as">
<span class="sig-name descname"><span class="pre">same_shape_as</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.dpl.pattern.DFPattern"><span class="pre">DFPattern</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">SameShapeConstraint</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.same_shape_as" title="Permalink to this definition">¶</a></dt>
<dd><p>The current pattern with the same shape as another pattern (sequence)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<em>List</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern"><em>DFPattern</em></a><em>]</em>) – The other pattern (sequence)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – A chained pattern sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PatternSeq</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.DFPattern.used_by">
<span class="sig-name descname"><span class="pre">used_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.dpl.pattern.DFPattern"><span class="pre">DFPattern</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">PatternSeq</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">PatternSeq</span></span></span><a class="headerlink" href="#tvm.relax.transform.DFPattern.used_by" title="Permalink to this definition">¶</a></dt>
<dd><p>The current pattern being used by another pattern (sequence)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern"><em>DFPattern</em></a><em>, </em><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern"><em>DFPattern</em></a><em>]</em>) – The consumer pattern (sequence)</p></li>
<li><p><strong>index</strong> (<em>int</em><em>, </em><em>optional</em>) – The argument index called by the consumer pattern, by default -1</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – A chained pattern sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PatternSeq</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.DataflowBlockPass">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">DataflowBlockPass</span></span><a class="headerlink" href="#tvm.relax.transform.DataflowBlockPass" title="Permalink to this definition">¶</a></dt>
<dd><p>A pass that works on each tvm.relax.DataflowBlock in a module.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.DeadCodeElimination">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">DeadCodeElimination</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">entry_functions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.DeadCodeElimination" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Remove dead code in the IRModule.</dt><dd><p>Currently it removes:
1. Unused local VarBindings in a DataflowBlock.
2. Unused DataflowBlocks in a function.
3. Unused Relax functions in the module.</p>
<blockquote>
<div><p>We detect the call chain from the entry function, and remove all unused functions.</p>
</div></blockquote>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>entry_functions</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em>) – The set of entry functions to start from.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For function-wise DCE, use py:func:<cite>tvm.relax.analysis.remove_all_unused</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.DecomposeOpsForInference">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">DecomposeOpsForInference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.DecomposeOpsForInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose composite operators that are composed by other operators during inference.
For example, the result of batch norm (a triple) will be simplified. Attention, tensor_to_shape,
etc. can be also decomposed into a number of simplified operators as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the specified function. If not specified, the pass will run in
all functions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.DecomposeOpsForTraining">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">DecomposeOpsForTraining</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.DecomposeOpsForTraining" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose composite operators that are composed by other operators during training.
For example, the result of batch norm (a triple) will be simplified. Attention, tensor_to_shape,
etc. can be also decomposed into a number of simplified operators as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the specified function. If not specified, the pass will run in
all functions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.EliminateCommonSubexpr">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">EliminateCommonSubexpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">call_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.transform.FunctionPass" title="tvm.relax.transform.transform.FunctionPass"><span class="pre">FunctionPass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.EliminateCommonSubexpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate common subexpressions within functions.</p>
<p>Note: For nested functions, this pass performs CSE <em>within</em> those functions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>call_only</strong> (<em>bool</em>) – If True, enable eliminating only call nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass that eliminates common subexpressions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tvm.relax.transform.Expr">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">Expr</span></span><a class="headerlink" href="#tvm.relax.transform.Expr" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><code class="xref py py-class docutils literal notranslate"><span class="pre">RelayExpr</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.FewShotTuning">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FewShotTuning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valid_count</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">benchmark</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.FewShotTuning" title="Permalink to this definition">¶</a></dt>
<dd><p>The pass is designed for few shot tuning for static shape PrimFuncs. It examines all the
blocks within the PrimFunc and conducts loop fusion, splitting, and other transformations based
on MetaSchedule schedule rules but directly samples from the search space instead of using the
tuning algorithm. User can specify the number of valid counts to try and whether to use runner
for benchmarking.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>valid_count</strong> (<em>int</em>) – The number of valid counts to try.</p></li>
<li><p><strong>benchmark</strong> (<em>bool</em>) – Whether to use runner for benchmarking.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.FoldConstant">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FoldConstant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.FoldConstant" title="Permalink to this definition">¶</a></dt>
<dd><p>Fold constant expressions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.FoldDataflowBlockOutput">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FoldDataflowBlockOutput</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.FoldDataflowBlockOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>If a dataflow var is used only in a binding to the dataflow block
output var (i.e., a non-dataflow var), this removes the dataflow var
and replaces the output var’s binding with the dataflow var’s direct definition.</p>
<p>This “cleans up” a situation that commonly arises when using <cite>CanonicalizeBindings</cite>
and <cite>DeadCodeElimination</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.FunctionPass">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FunctionPass</span></span><a class="headerlink" href="#tvm.relax.transform.FunctionPass" title="Permalink to this definition">¶</a></dt>
<dd><p>A pass that works on each tvm.relax.Function in a module. A function
pass class should be created through <cite>function_pass</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.FuseOps">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FuseOps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fuse_opt_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.FuseOps" title="Permalink to this definition">¶</a></dt>
<dd><p>This pass groups bindings in a dataflow block of Relax functions and generate a new grouped
Relax function for each group, according to the fusion algorithm described in the pass
implementation. By grouping bindings into new Relax functions, we substitute the bindings in
the function being manipulated into function calls to the new grouped function.</p>
<p>A follow-up pass named “FuseTIR” will generate a TIR PrimFunc for each grouped function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fuse_opt_level</strong> (<em>int</em>) – The level of fuse optimization. -1 indicates that the level will be
inferred from pass context.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass for operator fusion.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.FuseOpsByPattern">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FuseOpsByPattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">patterns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.FusionPattern" title="tvm.relax.transform.transform.FusionPattern"><span class="pre">FusionPattern</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bind_constants</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotate_codegen</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.FuseOpsByPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply pattern matching to each function in the given module, and group matched expressions
into a new function.</p>
<p>The end result is similar to FuseOps, but fusion is driven completely by the provided patterns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>patterns</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.FusionPattern" title="tvm.relax.transform.FusionPattern"><em>FusionPattern</em></a><em>, </em><em>Tuple</em><em>]</em><em>]</em>) – <p>A list of patterns to be matched. The order of the patterns determines the order of priority
in which they are matched. Higher-priority patterns should come earlier in the list.</p>
<p>In addition to FusionPattern, a tuple can be passed as item of this list. The pattern
will be constructed through FusionPattern(<a href="#id1"><span class="problematic" id="id2">*</span></a>item)</p>
</p></li>
<li><p><strong>bind_constants</strong> (<em>bool</em>) – Whether or not to keep bound constants in the grouped function.</p></li>
<li><p><strong>annotate_codegen</strong> (<em>bool</em>) – <p>If True, wrap each created composite function with another function, whose body consists
only of a call to the composite function, and annotate the outer function with “Codegen”
and “global_symbol” attributes. The “Codegen” attribute is set as the prefix of the
corresponding pattern name. For example, “dnnl” if the pattern name is “dnnl.conv2d_relu”.</p>
<p>This must be True if the created composite functions are intended to be offloaded to
an external backend without using the MergeCompositeFunctions pass.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass for pattern-based fusion.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.FuseTIR">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FuseTIR</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.FuseTIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Fuse primitive relax function into a larger TIR function if possible</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for tir fusion.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.FusionPattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">FusionPattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.dpl.pattern.DFPattern"><span class="pre">DFPattern</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotation_patterns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.dpl.pattern.DFPattern"><span class="pre">DFPattern</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.FusionPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>The pattern used by <cite>FuseOpsByPattern</cite>. It’s mainly DFPattern but with other
information to help during the fusion pass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – The name of pattern. Usually it starts with the name of backend, like ‘cutlass.matmul’.</p></li>
<li><p><strong>pattern</strong> (<a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern"><em>DFPattern</em></a>) – The dataflow pattern that will be used to match expressions that can be handled
by external backends.</p></li>
<li><p><strong>annotation_patterns</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#tvm.relax.transform.DFPattern" title="tvm.relax.transform.DFPattern"><em>DFPattern</em></a><em>]</em>) – The map which is used to extract important expressions from the pattern match
result. All DFPattern in this map should be part of the <cite>pattern</cite>.</p></li>
<li><p><strong>check</strong> (<em>Callable</em><em>[</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.PatternCheckContext" title="tvm.relax.transform.PatternCheckContext"><em>PatternCheckContext</em></a><em>]</em><em>, </em><em>bool</em><em>]</em>) – The function to check whether the match result is accepted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.Gradient">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">Gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">require_grads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.Gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse-mode automatic differentiation.</p>
<p>This pass will differentiate one function in the IRModule. Now the input function must have only
one dataflow block.</p>
<p>For a given function specified by <cite>func_name</cite>, it generates a new function with the name
<cite>func_name + “_adjoint”</cite>. The new function computes the gradient of the <strong>differentiation
target</strong> with respect to the arguments specified by <cite>require_grads</cite> of the original function.</p>
<p>If the function has only one return value, the return value will be specified as target. If the
function has more than one return values, the target will be specified as the target_index-th
return value. The target must be a scalar (0-dim tensor).</p>
<p>The new function will be like:</p>
<p>This AD pass also supports checkpointing as described in
“Training deep nets with sublinear memory cost.” - Chen, Tianqi, et al. (2016).
See tvm.relax.testing.nn.checkpoint for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func_name</strong> (<em>str</em>) – The name of the specific function.</p></li>
<li><p><strong>require_grads</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>relax.Var</em><em>, </em><em>List</em><em>[</em><em>relax.Var</em><em>]</em><em>]</em><em>]</em>) – The relax variables whose adjoints is needed. Must be parameters of the given function and
should not be duplicate. If it is not specified, adjoints of all parameters would be
computed.</p></li>
<li><p><strong>target_index</strong> (<em>int</em>) – If the specified function has more than one return values, specify the index of the return
value as the target. If it is not specified, the first return value will be the target.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The Pass.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The following code shows how to use this pass:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@I</span><span class="o">.</span><span class="n">ir_module</span>
<span class="k">class</span> <span class="nc">Module</span><span class="p">:</span>
    <span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">y</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">R</span><span class="o">.</span><span class="n">dataflow</span><span class="p">():</span>
            <span class="n">lv1</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># use R.sum to reduce the tensor to a scalar</span>
            <span class="n">lv2</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lv1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">R</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">lv2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lv2</span>

<span class="n">After</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Gradient</span><span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">)(</span><span class="n">Module</span><span class="p">)</span>
</pre></div>
</div>
<p>The module after the Gradient pass will be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@I</span><span class="o">.</span><span class="n">ir_module</span>
<span class="k">class</span> <span class="nc">After</span><span class="p">:</span>
    <span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">y</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">R</span><span class="o">.</span><span class="n">dataflow</span><span class="p">():</span>
            <span class="n">lv1</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">lv2</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lv1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">R</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">lv2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lv2</span>

    <span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
    <span class="k">def</span> <span class="nf">main_adjoint</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">y</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span>
        <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span>
        <span class="n">R</span><span class="o">.</span><span class="n">Tuple</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)),</span>
    <span class="p">):</span>
        <span class="k">with</span> <span class="n">R</span><span class="o">.</span><span class="n">dataflow</span><span class="p">():</span>
            <span class="c1"># original bindings</span>
            <span class="n">lv1</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">lv2</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lv1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># bindings w.r.t. intermediate variables</span>
            <span class="n">lv2_adjoint</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">ones</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">lv1_adjoint</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
                <span class="n">lv2_adjoint</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># bindings w.r.t. parameters</span>
            <span class="n">x_adjoint</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">lv1_adjoint</span>
            <span class="n">y_adjoint</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">lv1_adjoint</span>
            <span class="n">R</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">lv2</span><span class="p">,</span> <span class="n">x_adjoint</span><span class="p">,</span> <span class="n">y_adjoint</span><span class="p">)</span>
        <span class="c1"># return value: (orig_return_values, tuple(adjoints))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lv2</span><span class="p">,</span> <span class="p">(</span><span class="n">x_adjoint</span><span class="p">,</span> <span class="n">y_adjoint</span><span class="p">))</span>
</pre></div>
</div>
<p>The second example is returning multiple values and specifying the target with <cite>target_index</cite>:</p>
<p>The module after the Gradient pass will be:</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">IndexMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_index_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.IndexMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from multi-dimensional indices to another set of multi-dimensional indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_indices</strong> (<em>List</em><em>[</em><em>relax.Var</em><em>]</em>) – Variables representing the indices prior to remapping.</p></li>
<li><p><strong>final_indices</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – Expressions defining the indices after remapping.</p></li>
<li><p><strong>inverse_index_map</strong> (<em>Union</em><em>[</em><em>Callable</em><em>, </em><em>Optional</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap"><em>IndexMap</em></a><em>]</em><em>]</em>) – The optional pre-defined inverse index map.
When this is defined, IndexMap::Inverse will return the pre-defined inverse index map.
Otherwise, the inverse index map will be computed on the fly.
It is the user’s responsibility to ensure the correctness of the pre-defined inverse
index map.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.from_func">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'int64'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.IndexMap.from_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an index map from a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mapping_function</strong> (<em>Callable</em>) – The function to map from source indices to target indices.
The function should accept <cite>tir.Var</cite> parameters and return
a either a <cite>tir.PrimExpr</cite>, or a list of <cite>tir.PrimExpr</cite>.
Returning a <cite>tir.PrimExpr</cite> is equivalent to returning a
list of length 1 containing that <cite>tir.PrimExpr</cite>.</p></li>
<li><p><strong>ndim</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The dimensionality of the buffer to which this
transformation should be applied.  If mapping_function uses
variadic argument <cite>*args</cite>, <cite>ndim</cite> must be specified.  If
mapping_function does not use variadic arguments, ndim is
optional.</p></li>
<li><p><strong>inverse_index_map</strong> (<em>Union</em><em>[</em><em>Callable</em><em>, </em><em>Optional</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap"><em>IndexMap</em></a><em>]</em><em>]</em>) – The optional pre-defined inverse index map.
When this is defined, IndexMap::Inverse will return the pre-defined inverse index map.
Otherwise, the inverse index map will be computed on the fly.
It is the user’s responsibility to ensure the correctness of the pre-defined inverse
index map.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index_map</strong> – Returns an IndexMap representing the <cite>mapping_function</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap">IndexMap</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.from_func_with_separators">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_func_with_separators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'int64'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.IndexMap.from_func_with_separators" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an index map from a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mapping_function</strong> (<em>Callable</em>) – The function to map from source indices to target indices.
The function should accept tir.Var parameters and return
either a <cite>tir.PrimExpr</cite> or a list.  Each element of the
returned list should be either a <cite>tir.PrimExpr</cite> or the
object <cite>IndexMap.AXIS_SEPARATOR</cite>.  Returning a
<cite>tir.PrimExpr</cite> is equivalent to returning a list of length
1 containing that <cite>tir.PrimExpr</cite>.</p></li>
<li><p><strong>ndim</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The dimensionality of the buffer to which this
transformation should be applied.  If mapping_function uses
variadic argument <cite>*args</cite>, ndim must be specified.  If
mapping_function does not use variadic arguments, ndim is
optional.</p></li>
<li><p><strong>inverse_index_map</strong> (<em>Union</em><em>[</em><em>Callable</em><em>, </em><em>Optional</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap"><em>IndexMap</em></a><em>]</em><em>]</em>) – The optional pre-defined inverse index map.
When this is defined, IndexMap::Inverse will return the pre-defined inverse index map.
Otherwise, the inverse index map will be computed on the fly.
It is the user’s responsibility to ensure the correctness of the pre-defined inverse
index map.</p></li>
<li><p><strong>index_dtype</strong> (<em>str</em>) – The default index dtype to use for input iters in the mapping function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – Returns a tuple whose first element is an IndexMap
representing the <cite>mapping_function</cite>, and whose second index
is a list of indices at which <cite>IndexMap.AXIS_SEPARATOR</cite>
occurred.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap">IndexMap</a>, List[int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.expr.Range"><span class="pre">Range</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.IndexMap.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of the map</p>
<p>Throws an error if the function is not bijective.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.Range"><em>Range</em></a><em>,</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em><em>]</em>) – The region over which the inverse should be determined.
Used for validating that the mapping is bijective over
this range.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>inverse</strong> – The inverse</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap">IndexMap</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.is_equivalent_to">
<span class="sig-name descname"><span class="pre">is_equivalent_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#tvm.relax.transform.IndexMap.is_equivalent_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index maps are equivalent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other_map</strong> (<a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap"><em>IndexMap</em></a>) – The IndexMap to which the comparison should be made.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>is_equivalent</strong> – True if the two mappings represent the same
transformation, otherwise False</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.map_indices">
<span class="sig-name descname"><span class="pre">map_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.transform.IndexMap.map_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the index map to a set of indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>indices</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – The indices to be mapped</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The mapped indices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.map_ndarray">
<span class="sig-name descname"><span class="pre">map_ndarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_src</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../runtime/ndarray.html#tvm.runtime.ndarray.NDArray" title="tvm.runtime.ndarray.NDArray"><span class="pre">NDArray</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../runtime/ndarray.html#tvm.runtime.ndarray.NDArray" title="tvm.runtime.ndarray.NDArray"><span class="pre">NDArray</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.IndexMap.map_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply thie index map to transform the layout of the input NDArray</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>arr_src</strong> (<em>runtime.NDArray</em>) – The NDArray to be transformed</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>arr_dst</strong> – The transformed NDArray</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>runtime.NDArray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.map_shape">
<span class="sig-name descname"><span class="pre">map_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.transform.IndexMap.map_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the index map to a buffer shape</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – The buffer shape to be mapped</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The mapped shape</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.IndexMap.non_surjective_inverse">
<span class="sig-name descname"><span class="pre">non_surjective_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.expr.Range"><span class="pre">Range</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.transform.IndexMap.non_surjective_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of the map</p>
<p>Can be applied to transformations that introduce padding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.Range"><em>Range</em></a><em>,</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em><em>]</em>) – The region over which the inverse should be determined.
Used for determining the predicate.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The inverse, and a predicate for which the inverse maps to
a valid index in the input range.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="#tvm.relax.transform.IndexMap" title="tvm.relax.transform.IndexMap">IndexMap</a>, <a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a>]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">index_map</span> <span class="o">=</span> <span class="n">IndexMap</span><span class="o">.</span><span class="n">from_func</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span> <span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="p">])</span>
<span class="n">inverse_map</span><span class="p">,</span> <span class="n">predicate</span> <span class="o">=</span> <span class="n">index_map</span><span class="o">.</span><span class="n">non_surjective_inverse</span><span class="p">([</span><span class="mi">14</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">inverse_map</span><span class="o">.</span><span class="n">is_equivalent_to</span><span class="p">(</span><span class="n">IndexMap</span><span class="o">.</span><span class="n">from_func</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span> <span class="c1"># Prints &quot;(axis0==3) &amp;&amp; (axis2 &gt;= 2)&quot;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.LambdaLift">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">LambdaLift</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.LambdaLift" title="Permalink to this definition">¶</a></dt>
<dd><p>A pass that lifts local functions into global.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.LazyTransformParams">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">LazyTransformParams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.LazyTransformParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert transform_params functions into a lazy version.
(Load the input to memory on demand, and immediately free it after the last use.)</p>
<p>Note: ToNonDataflow() and RemovePurityTracking() should be invoked before this pass.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.LegalizeOps">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">LegalizeOps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">customize_legalize_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="block_builder.html#tvm.relax.block_builder.BlockBuilder" title="tvm.relax.block_builder.BlockBuilder"><span class="pre">BlockBuilder</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.memory.Call" title="tvm.relax.expr.Call"><span class="pre">Call</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enable_warning</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.LegalizeOps" title="Permalink to this definition">¶</a></dt>
<dd><p>Legalize high-level operator calls in Relax functions to call_tir
with corresponding low-level TIR PrimFuncs.</p>
<p>For each high-level operator, we register the way of legalizing it as a
function, which takes a context BlockBuilder and the relax.Call being legalized
as input, and returns the legalized call. Here the input BlockBuilder is
mainly used for adding the PrimFunc created by call_te into the context
IRModule.</p>
<p>The legalization function for each operator is registered as an attribute (with
attribute key <cite>FLegalize</cite>) of the operator.</p>
<p>This pass provides customizability for users to use their own legalization
function for operators. The pass takes an optional customized map,
with the key to be the operator name (<cite>str</cite>) and value to be the function
(<cite>LegalizeFunc</cite>). The default legalization function will be overridden by the customized
one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>customize_legalize_map</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>LegalizeFunc</em><em>]</em><em>]</em>) – The customized operator legalization function map. The customized function will override
the default one.</p></li>
<li><p><strong>enable_warning</strong> (<em>bool</em>) – A boolean value indicating if to print warnings for CallNode whose op’s
legalization function is not registered. By default we don’t print
warnings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The following code shows how to use this pass:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the pass input IRModule</span>
<span class="nd">@tvm</span><span class="o">.</span><span class="n">script</span><span class="o">.</span><span class="n">ir_module</span>
<span class="k">class</span> <span class="nc">Module</span><span class="p">:</span>
    <span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">y</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">):</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">r</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

<span class="c1"># Define the customized legalization function for &quot;relax.add&quot;</span>
<span class="k">def</span> <span class="nf">customize_legalize_add</span><span class="p">(</span><span class="n">bb</span><span class="p">:</span> <span class="n">relax</span><span class="o">.</span><span class="n">BlockBuilder</span><span class="p">,</span> <span class="n">call</span><span class="p">:</span> <span class="n">relax</span><span class="o">.</span><span class="n">Call</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">relax</span><span class="o">.</span><span class="n">Expr</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tvm</span> <span class="kn">import</span> <span class="n">topi</span>
    <span class="k">return</span> <span class="n">bb</span><span class="o">.</span><span class="n">call_te</span><span class="p">(</span><span class="n">topi</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">call</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">call</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Apply the pass with the customized function to the module.</span>
<span class="n">mod</span> <span class="o">=</span> <span class="n">LegalizeOps</span><span class="p">({</span><span class="s2">&quot;relax.add&quot;</span><span class="p">:</span> <span class="n">customize_legalize_add</span><span class="p">})(</span><span class="n">Module</span><span class="p">)</span>
</pre></div>
</div>
<p>Print out the result by <cite>mod.show()</cite>, we can see the IRModule after
legalization becomes</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@tvm</span><span class="o">.</span><span class="n">script</span><span class="o">.</span><span class="n">ir_module</span>
<span class="k">class</span> <span class="nc">Module</span><span class="p">:</span>
    <span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">y</span><span class="p">:</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="o">.</span><span class="n">Tensor</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">call_tir</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">call_tir</span><span class="p">(</span><span class="n">multiply</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="nd">@T</span><span class="o">.</span><span class="n">prim_func</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">Buffer</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">Buffer</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span>
        <span class="n">T_add</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">Buffer</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="n">T</span><span class="o">.</span><span class="n">func_attr</span><span class="p">({</span><span class="s2">&quot;tir.noalias&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">T</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="s2">&quot;T_add&quot;</span><span class="p">):</span>
                <span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="s2">&quot;SS&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">])</span>
                <span class="n">T</span><span class="o">.</span><span class="n">reads</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">])</span>
                <span class="n">T</span><span class="o">.</span><span class="n">writes</span><span class="p">(</span><span class="n">T_add</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">])</span>
                <span class="n">T_add</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">]</span>

    <span class="nd">@T</span><span class="o">.</span><span class="n">prim_func</span>
    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span>
        <span class="n">A</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">Buffer</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">Buffer</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span>
        <span class="n">T_multiply</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">Buffer</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="n">T</span><span class="o">.</span><span class="n">func_attr</span><span class="p">({</span><span class="s2">&quot;tir.noalias&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">T</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="s2">&quot;T_multiply&quot;</span><span class="p">):</span>
                <span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="s2">&quot;SS&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">])</span>
                <span class="n">T</span><span class="o">.</span><span class="n">reads</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">])</span>
                <span class="n">T</span><span class="o">.</span><span class="n">writes</span><span class="p">(</span><span class="n">T_multiply</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">])</span>
                <span class="n">T_multiply</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">v_ax0</span><span class="p">,</span> <span class="n">v_ax1</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.LiftTransformParams">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">LiftTransformParams</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.LiftTransformParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Lift transformation of the parameters of a function.</p>
<p>When some inputs of the function is marked as ‘parameters’ (the model weights), this pass
identifies the transformation of the parameters and lifts them to a separate function called
<cite>transform_params</cite>. <cite>transform_params</cite> takes a tuple of the original parameters as input and
returns a tuple of the transformed parameters. The original function will be rewritten to accept
a tuple of transformed parameters as input.</p>
<p>Users are expected to invoke the <cite>transform_params</cite> function in runtime and pass the transformed
parameters to the original function as input.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for lifting transformation of parameters.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.MergeCompositeFunctions">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">MergeCompositeFunctions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.MergeCompositeFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Group one or multiple composite functions created by FuseOpsByPattern into a new function.
The new function will be annotated with “Codegen” and “global_symbol” attributes, and it
is intented to be offloaded to an external backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for merging composite functions.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.MetaScheduleApplyDatabase">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">MetaScheduleApplyDatabase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">work_dir</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enable_warning</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.MetaScheduleApplyDatabase" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the best schedule from tuning database.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>work_dir</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – work directory to deduce default database if database is not provided
(it will be ignored when an user passes database)</p></li>
<li><p><strong>enable_warning</strong> (<em>bool</em>) – A boolean value indicating if to print warnings for TIR functions not
showing up in the database. By default we don’t print warning.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.MetaScheduleTuneIRMod">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">MetaScheduleTuneIRMod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../runtime/ndarray.html#tvm.runtime.ndarray.NDArray" title="tvm.runtime.ndarray.NDArray"><span class="pre">NDArray</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">work_dir</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_trials_global</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_trials_per_task</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op_names</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.MetaScheduleTuneIRMod" title="Permalink to this definition">¶</a></dt>
<dd><p>Tune Relax IRModule with MetaSchedule.
:param params: model params
:type params: Dict[str, NDArray]
:param work_dir: work directory
:type work_dir: str
:param max_trials_gloabl: maximum number of total trials allowed for tuning
:type max_trials_gloabl: int
:param max_trials_per_task: maximum number of trials per task
:type max_trials_per_task: int
:param op_names:</p>
<blockquote>
<div><dl class="simple">
<dt>A list of operator names to specify which op to tune. When it is None, all operators</dt><dd><p>are tuned.</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.MetaScheduleTuneTIR">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">MetaScheduleTuneTIR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">work_dir</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_trials_global</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.MetaScheduleTuneTIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Tune TIR with MetaSchedule.
:param work_dir: work directory
:type work_dir: str
:param max_trials_gloabl: maximum number of total trials allowed for tuning
:type max_trials_gloabl: int</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">NDArray</span></span><a class="headerlink" href="#tvm.relax.transform.NDArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Lightweight NDArray class of TVM runtime.</p>
<p>Strictly this is only an Array Container (a buffer object)
No arthimetic operations are defined.
All operations are performed by TVM functions.</p>
<p>The goal is not to re-build yet another array library.
Instead, this is a minimal data structure to demonstrate
how can we use TVM in existing project which might have their own array containers.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray.asnumpy">
<span class="sig-name descname"><span class="pre">asnumpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.NDArray.asnumpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this array to numpy array. This API will be deprecated in TVM v0.8 release.
Please use <cite>numpy</cite> instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray.copyfrom">
<span class="sig-name descname"><span class="pre">copyfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.NDArray.copyfrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a synchronous copy from the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>source_array</strong> (<em>array_like</em>) – The data source we should like to copy from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>arr</strong> – Reference to self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.transform.NDArray" title="tvm.relax.transform.NDArray">NDArray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray.copyto">
<span class="sig-name descname"><span class="pre">copyto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mem_scope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.NDArray.copyto" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy array to target</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> (<a class="reference internal" href="#tvm.relax.transform.NDArray" title="tvm.relax.transform.NDArray"><em>NDArray</em></a>) – The target array to be copied, must have same shape as this array.</p></li>
<li><p><strong>mem_scope</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The memory scope of the array.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#tvm.relax.transform.NDArray.device" title="Permalink to this definition">¶</a></dt>
<dd><p>Device of this array</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#tvm.relax.transform.NDArray.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of this array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray.numpy">
<span class="sig-name descname"><span class="pre">numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.NDArray.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this array to numpy array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>np_arr</strong> – The corresponding numpy array.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.NDArray.same_as">
<span class="sig-name descname"><span class="pre">same_as</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.NDArray.same_as" title="Permalink to this definition">¶</a></dt>
<dd><p>Check object identity equality</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<em>object</em>) – The other object to compare to</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>same</strong> – Whether other is same as self.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.Normalize">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">Normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.Normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforming Relax IR to normal form, i.e., the expressions are normalized(no nesting
and hence the AST is in ANF), and all <a href="#id3"><span class="problematic" id="id4">checked_type_</span></a> and <a href="#id5"><span class="problematic" id="id6">shape_</span></a> of expressions are available.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.Object">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">Object</span></span><a class="headerlink" href="#tvm.relax.transform.Object" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all tvm’s runtime objects.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.OptimizeLayoutTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">OptimizeLayoutTransform</span></span><a class="headerlink" href="#tvm.relax.transform.OptimizeLayoutTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass to remove redundant transform layout operators
introduced by AlterOpImpl pass.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.PatternCheckContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">PatternCheckContext</span></span><a class="headerlink" href="#tvm.relax.transform.PatternCheckContext" title="Permalink to this definition">¶</a></dt>
<dd><p>The input of check function <cite>FusionPattern.check</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matched_expr</strong> (<em>Expr</em>) – The expression that’s matched with the FusionPattern.pattern.</p></li>
<li><p><strong>annotated_expr</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Expr</em><em>]</em>) – A map which contains all expressions matched by the sub patterns in
FusionPattern.annotation_patterns.</p></li>
<li><p><strong>matched_bindings</strong> (<em>Mapping</em><em>[</em><em>relax.Var</em><em>, </em><em>Expr</em><em>]</em>) – Map from variable to its value. It contains variables from bindings that is
being fused by FuseOpsByPattern.</p></li>
<li><p><strong>var_usages</strong> (<em>Mapping</em><em>[</em><em>relax.Var</em><em>, </em><em>Sequence</em><em>[</em><em>relax.Var</em><em>]</em><em>]</em>) – A map mapping variable definitions to a set of uses. It has all variables
used in the function.</p></li>
<li><p><strong>value_to_bound_var</strong> (<em>Mapping</em><em>[</em><em>Expr</em><em>, </em><em>relax.Var</em><em>]</em>) – Map from value to its bound variable. It doesn’t have variables after the
matched expression.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.PrimFunc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">PrimFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.PrimFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>A function declaration expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.Var"><em>tvm.tir.Var</em></a><em>, </em><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><em>tvm.tir.Buffer</em></a><em>]</em><em>]</em>) – List of input parameters to the function.</p></li>
<li><p><strong>body</strong> (<a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><em>tvm.tir.Stmt</em></a>) – The body of the function.</p></li>
<li><p><strong>ret_type</strong> (<a class="reference internal" href="../ir.html#tvm.ir.Type" title="tvm.ir.Type"><em>tvm.ir.Type</em></a>) – The return type annotation of the function.</p></li>
<li><p><strong>buffer_map</strong> (<a class="reference internal" href="../ir.html#tvm.ir.Map" title="tvm.ir.Map"><em>Map</em></a><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.Var"><em>tvm.tir.Var</em></a><em>, </em><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><em>tvm.tir.Buffer</em></a><em>]</em>) – The buffer binding map.</p></li>
<li><p><strong>attrs</strong> (<em>Optional</em><em>[</em><em>tvm.Attrs</em><em>]</em>) – Attributes of the function, can be None</p></li>
<li><p><strong>span</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.Span"><em>Span</em></a><em>]</em>) – The location of this itervar in the source code.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.PrimFunc.specialize">
<span class="sig-name descname"><span class="pre">specialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.buffer.Buffer"><span class="pre">Buffer</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.PrimFunc.specialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialize parameters of PrimFunc</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param_map</strong> (<em>Mapping</em><em>[</em><em>relax.Var</em><em>, </em><em>Union</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>, </em><a class="reference internal" href="analysis.html#tvm.relax.analysis.Buffer" title="tvm.relax.analysis.Buffer"><em>Buffer</em></a><em>]</em><em>]</em>) – The mapping from function params to the instance</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We can define a Meta TIR function with symbolic shape:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@T</span><span class="o">.</span><span class="n">prim_func</span>
<span class="k">def</span> <span class="nf">mem_copy</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">T</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="n">vi</span><span class="p">,</span> <span class="n">vj</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="s2">&quot;SS&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">B</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span>
</pre></div>
</div>
<p>Then we can make it specialized with given shapes or buffers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mem_copy</span><span class="o">.</span><span class="n">params</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">mem_copy</span><span class="o">.</span><span class="n">specialize</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="n">tir</span><span class="o">.</span><span class="n">decl_buffer</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))})</span>
<span class="c1"># or</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">mem_copy</span><span class="o">.</span><span class="n">specialize</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="mi">16</span><span class="p">})</span>
</pre></div>
</div>
<p>The specialized function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@T</span><span class="o">.</span><span class="n">prim_func</span>
<span class="k">def</span> <span class="nf">mem_copy_16_16</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">T</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="n">vi</span><span class="p">,</span> <span class="n">vj</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="s2">&quot;SS&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">B</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> – The new function with parameter specialized</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.relax.transform.PrimFunc" title="tvm.relax.transform.PrimFunc">PrimFunc</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.transform.PrimFunc.with_body">
<span class="sig-name descname"><span class="pre">with_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_body</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.PrimFunc.with_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new PrimFunc with the same set signatures but a new body.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_body</strong> (<a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><em>Stmt</em></a>) – The new body.</p></li>
<li><p><strong>span</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.Span"><em>Span</em></a><em>]</em>) – The location of this itervar in the source code.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>new_func</strong> – The created new function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.transform.PrimFunc" title="tvm.relax.transform.PrimFunc">PrimFunc</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.RealizeVDevice">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">RealizeVDevice</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.RealizeVDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate virtual device information.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.RemovePurityChecking">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">RemovePurityChecking</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.RemovePurityChecking" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate relax.force_pure on all pure functions in the module
and unwrap all pure override ops into the normal versions.</p>
<p>This effectively means that there will be no more purity tracking,
useful for low-level code generation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The Pass.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should be used after ToNonDataflow()</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.RewriteCUDAGraph">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">RewriteCUDAGraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.RewriteCUDAGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite a Relax module for executing with CUDA graph. This pass identifies the regions that
can be executed with CUDA graph and lifts them into new functions for runtime graph capturing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for rewriting cuda graph</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.RewriteDataflowReshape">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">RewriteDataflowReshape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.RewriteDataflowReshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all reshape-like call_tir to VM reshape operator call.
The VM reshape operator calls will be further lowered to a CreateView
operation at runtime, instead of doing real data copy.
Here “reshape-like” includes reshape, expand_dims, flatten, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.RunCodegen">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">RunCodegen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">dict</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry_functions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.RunCodegen" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce the runtime::Module with an annotated codegen and global symbol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_options</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – Pairs of a target name and compilation options</p></li>
<li><p><strong>entry_functions</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em>) – The set of entry functions to start from.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass to remove unused functions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.SplitCallTIRByPattern">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">SplitCallTIRByPattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">patterns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fcodegen</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.SplitCallTIRByPattern" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Split a PrimFunc into 2 parts: the first part is a TIR PrimFunc which is</dt><dd><p>matched with some pattern, and the second part is the rest of the original
PrimFunc. It will call fcodegen to generate the code for the matched pattern
to replace it with a ExternFunc call.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>patterns</strong> (<em>List</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.PrimFunc" title="tvm.relax.transform.PrimFunc"><em>PrimFunc</em></a><em>]</em>) – The list of patterns to match.</p></li>
<li><p><strong>fcodegen</strong> (<em>Callable</em><em>[</em><em>[</em><em>List</em><em>[</em><em>MatchResult</em><em>]</em><em>]</em><em>, </em><em>List</em><em>[</em><a class="reference internal" href="#tvm.relax.transform.Object" title="tvm.relax.transform.Object"><em>Object</em></a><em>]</em><em>]</em>) – The function to generate the code for the matched patterns.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass for splitting call_tir.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.StaticPlanBlockMemory">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">StaticPlanBlockMemory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.StaticPlanBlockMemory" title="Permalink to this definition">¶</a></dt>
<dd><p>The static memory planning pass on BindingBlock level.
The pass will reuse allocated memory to its best effort, in order to
reduce the total amount of allocated memory size.</p>
<p>The pass “supports” dynamic shape in the way of TIR variable upper bound
annotation. We can optionally annotate the attribute “tir_var_upper_bound”
to Relax functions. The attribute value is a dict from strings to integers,
denoting the name of TIR variables to the upper bound values of the TIR vars.
Note: The annotated upper bound attribute only applies to TIR vars in the
function signature for clarity.</p>
<dl class="simple">
<dt>For example, we can annotate a Relax function with</dt><dd><p><cite>R.func_attr({“tir_var_upper_bound”: {“n”: 1024}})</cite>.</p>
</dd>
</dl>
<p>It means the maximum value of variable that names “n” in the function
signature will have upper bound 1024. And we will use 1024 as its value
during memory planning.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.ToMixedPrecision">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">ToMixedPrecision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out_dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'float32'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp16_input_names</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.ToMixedPrecision" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatic mixed precision pass. Currently the pass assumes the input module to be fp32
only, and will automatically cast fp32 to fp16 for certain ops.
:param out_dtype: The output data type of gemm/conv, which is the data type of the accumulator.
:type out_dtype: str
:param fp16_input_names: The names of function parameters whose dtype should become fp16. The  function signature</p>
<blockquote>
<div><p>would change accordingly.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – The registered pass for mixed precision.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.transform.Pass">tvm.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.ToNonDataflow">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">ToNonDataflow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.ToNonDataflow" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform all dataflow structure to non-dataflow version.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.UpdateVDevice">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">UpdateVDevice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_vdevice</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../ir.html#tvm.ir.VDevice" title="tvm.ir.global_info.VDevice"><span class="pre">VDevice</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.UpdateVDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>Update virtual device.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_vdevice</strong> (<a class="reference internal" href="../ir.html#tvm.ir.VDevice" title="tvm.ir.VDevice"><em>tvm.ir.VDevice</em></a>) – The new virtual device.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The device index indicates the device on which the update will be performed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The registered pass that modifies the virtual device.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.VMBuiltinLower">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">VMBuiltinLower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.VMBuiltinLower" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowering generic intrinsic to VM intrinsics.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.VMShapeLower">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">VMShapeLower</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emit_err_ctx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass"><span class="pre">Pass</span></a></span></span><a class="headerlink" href="#tvm.relax.transform.VMShapeLower" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower the symbolic shape and argument and match-cast structinfo matching.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>emit_err_ctx</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Whether emit err context string, can be turned off for testing purposes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../transform.html#tvm.transform.Pass" title="tvm.ir.transform.Pass">tvm.ir.transform.Pass</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.transform.Var">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">Var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_hint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Id</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">struct_info</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.transform.Var" title="Permalink to this definition">¶</a></dt>
<dd><p>The variable class for all Relax bindings.</p>
<dl class="py property">
<dt class="sig sig-object py" id="tvm.relax.transform.Var.name_hint">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name_hint</span></span><a class="headerlink" href="#tvm.relax.transform.Var.name_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Get name hint of the current var.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.dataflowblock_pass">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">dataflowblock_pass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#tvm.relax.transform.DataflowBlockPass" title="tvm.relax.transform.transform.DataflowBlockPass"><span class="pre">DataflowBlockPass</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.transform.dataflowblock_pass" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorate a dataflowblock pass.</p>
<p>This function returns a callback when pass_func
is provided. Otherwise, it returns the created dataflowblock pass using the
given optimization function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pass_func</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>(</em><a class="reference internal" href="analysis.html#tvm.relax.analysis.DataflowBlock" title="tvm.relax.analysis.DataflowBlock"><em>DataflowBlock</em></a><em>, </em><a class="reference internal" href="../runtime/runtime.html#tvm.runtime.Module" title="tvm.runtime.Module"><em>Module</em></a><em>, </em><a class="reference internal" href="../transform.html#tvm.transform.PassContext" title="tvm.transform.PassContext"><em>PassContext</em></a><em>) </em><em>-&gt; DataflowBlock</em><em>]</em><em>]</em>) – The transformation function or class.</p></li>
<li><p><strong>opt_level</strong> (<em>int</em>) – The optimization level of this dataflowblock pass.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the dataflowblock pass. The name could be empty. In this case, the
name of the optimization function will be used as the pass name.</p></li>
<li><p><strong>required</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em>) – The list of passes that the dataflowblock pass is dependent on.</p></li>
<li><p><strong>traceable</strong> (<em>Boolean</em>) – Boolean variable whether the dataflowblock pass is traceable</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>create_dataflowblock_pass</strong> – A decorator will be returned if pass_func is not provided,
otherwise return the decorated result.
The returned decorator has two behaviors depending on the input:
A new DataflowBlockPass will be returned when we decorate a pass function.
A new DataflowBlockPass class will be returned when we decorate a class type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[Callable, <a class="reference internal" href="#tvm.relax.transform.DataflowBlockPass" title="tvm.relax.transform.DataflowBlockPass">DataflowBlockPass</a>]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The following code block decorates a dataflowblock pass class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@relax</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">dataflowblock_pass</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TestReplaceBinding</span><span class="p">:</span>
    <span class="c1"># Simple test function to replace the first VarBinding to another.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create a new VarBinding</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">tir</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;int64&quot;</span><span class="p">),</span> <span class="n">tir</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">lv0</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="s2">&quot;lv1&quot;</span><span class="p">,</span> <span class="n">relax</span><span class="o">.</span><span class="n">TensorStructInfo</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">],</span> <span class="s2">&quot;float32&quot;</span><span class="p">))</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">const</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">56</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_binding</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">VarBinding</span><span class="p">(</span><span class="n">lv0</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_dataflowblock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="c1"># just for demo purposes</span>
        <span class="c1"># Replace the first binding in the DataflowBlock</span>
        <span class="n">new_bindings</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">new_binding</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">new_block</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">DataflowBlock</span><span class="p">(</span><span class="n">new_bindings</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">span</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_block</span>

<span class="nd">@tvm</span><span class="o">.</span><span class="n">script</span><span class="o">.</span><span class="n">ir_module</span>
<span class="k">class</span> <span class="nc">InputMod</span><span class="p">:</span>
    <span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
    <span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">]):</span>
        <span class="k">with</span> <span class="n">relax</span><span class="o">.</span><span class="n">dataflow</span><span class="p">():</span>
            <span class="n">lv0</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">gv0</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">relax</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">gv0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gv0</span>
<span class="c1"># block_pass is now a special pass that replaces every</span>
<span class="c1"># first binding to the constant value binding</span>
<span class="n">block_pass</span> <span class="o">=</span> <span class="n">TestReplaceBinding</span><span class="p">()</span>
<span class="c1"># now every first binding in DataflowBlock of InputMod</span>
<span class="c1"># is replaced by new_binding</span>
<span class="n">updated_mod</span> <span class="o">=</span> <span class="n">block_pass</span><span class="p">(</span><span class="n">InputMod</span><span class="p">)</span>
</pre></div>
</div>
<p>The following code creates a dataflowblock pass by decorating
a user defined transform function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@relax</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">dataflowblock_pass</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="c1"># my transformations here.</span>
    <span class="k">return</span> <span class="n">block</span>

<span class="n">block_pass</span> <span class="o">=</span> <span class="n">transform</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block_pass</span><span class="p">,</span> <span class="n">relax</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">DataflowBlockPass</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">block_pass</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">opt_level</span> <span class="o">==</span> <span class="mi">2</span>

<span class="c1"># Given a module m, the optimization could be invoked as the follwoing:</span>
<span class="n">updated_mod</span> <span class="o">=</span> <span class="n">block_pass</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="c1"># Now transform should have been applied to every DataflowBlock in</span>
<span class="c1"># the provided module m. And the updated module will be returned.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.transform.function_pass">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.transform.</span></span><span class="sig-name descname"><span class="pre">function_pass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pass_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">required</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#tvm.relax.transform.FunctionPass" title="tvm.relax.transform.transform.FunctionPass"><span class="pre">FunctionPass</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.transform.function_pass" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorate a function pass.</p>
<p>This function returns a callback when pass_func
is provided. Otherwise, it returns the created function pass using the
given optimization function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pass_func</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>(</em><a class="reference internal" href="analysis.html#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function"><em>Function</em></a><em>, </em><a class="reference internal" href="../runtime/runtime.html#tvm.runtime.Module" title="tvm.runtime.Module"><em>Module</em></a><em>, </em><a class="reference internal" href="../transform.html#tvm.transform.PassContext" title="tvm.transform.PassContext"><em>PassContext</em></a><em>) </em><em>-&gt; Function</em><em>]</em><em>]</em>) – The transformation function or class.</p></li>
<li><p><strong>opt_level</strong> (<em>int</em>) – The optimization level of this function pass.</p></li>
<li><p><strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the function pass. The name could be empty. In this case, the
name of the optimization function will be used as the pass name.</p></li>
<li><p><strong>required</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em>) – The list of passes that the function pass is dependent on.</p></li>
<li><p><strong>traceable</strong> (<em>Boolean</em>) – Boolean variable whether the function pass is traceable</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>create_function_pass</strong> – A decorator will be returned if pass_func is not provided,
otherwise return the decorated result.
The returned decorator has two behaviors depending on the input:
A new FunctionPass will be returned when we decorate a pass function.
A new FunctionPass class will be returned when we decorate a class type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[Callable, <a class="reference internal" href="#tvm.relax.transform.FunctionPass" title="tvm.relax.transform.FunctionPass">FunctionPass</a>]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The following code block decorates a function pass class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@relax</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">function_pass</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TestReplaceFunc</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_func</span> <span class="o">=</span> <span class="n">new_func</span>

    <span class="k">def</span> <span class="nf">transform_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="c1"># just for demo purposes</span>
        <span class="c1"># transform func to new_func</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_func</span>

<span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">]):</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="nd">@tvm</span><span class="o">.</span><span class="n">script</span><span class="o">.</span><span class="n">ir_module</span>
<span class="k">class</span> <span class="nc">InputMod</span><span class="p">:</span>
    <span class="nd">@R</span><span class="o">.</span><span class="n">function</span>
    <span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">]):</span>
        <span class="n">gv0</span> <span class="o">=</span> <span class="n">relax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gv0</span>
<span class="c1"># fpass is now a special pass that replaces every</span>
<span class="c1"># function to f1</span>
<span class="n">fpass</span> <span class="o">=</span> <span class="n">TestReplaceFunc</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
<span class="c1"># now every function in InputMod is replaced by f1</span>
<span class="n">updated_mod</span> <span class="o">=</span> <span class="n">fpass</span><span class="p">(</span><span class="n">InputMod</span><span class="p">)</span>
</pre></div>
</div>
<p>The following code creates a function pass by decorating
a user defined transform function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@relax</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">function_pass</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="c1"># my transformations here.</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="n">function_pass</span> <span class="o">=</span> <span class="n">transform</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function_pass</span><span class="p">,</span> <span class="n">relax</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">FunctionPass</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">function_pass</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">opt_level</span> <span class="o">==</span> <span class="mi">2</span>

<span class="c1"># Given a module m, the optimization could be invoked as the follwoing:</span>
<span class="n">updated_mod</span> <span class="o">=</span> <span class="n">function_pass</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="c1"># Now transform should have been applied to every function in</span>
<span class="c1"># the provided module m. And the updated module will be returned.</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
           
          </div>
          

<footer>

    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../rpc.html" class="btn btn-neutral float-right" title="tvm.rpc" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="op.html" class="btn btn-neutral float-left" title="tvm.relax.op" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>

<div id="button" class="backtop"><img src="../../../_static/img/right.svg" alt="backtop"/> </div>
<section class="footerSec">
    <div class="footerHeader">
      <div class="d-flex align-md-items-center justify-content-between flex-column flex-md-row">
        <div class="copywrite d-flex align-items-center">
          <h5 id="copy-right-info">© 2023 Apache Software Foundation | All rights reserved</h5>
        </div>
      </div>

    </div>

    <div>
      <div class="footernote">Copyright © 2023 The Apache Software Foundation. Apache TVM, Apache, the Apache feather, and the Apache TVM project logo are either trademarks or registered trademarks of the Apache Software Foundation.</div>
    </div>

</section>
</footer>
        </div>
      </div>

    </section>

  </div>
  

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  </body>
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>