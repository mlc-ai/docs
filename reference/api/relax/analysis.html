





<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tvm.relax.analysis &mdash; Apache TVM Unity 0.14.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/tabs.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/tlcpack_theme.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/tvm-logo-square.png"/>
  

  
  
  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <script type="text/javascript" src="../../../_static/js/tlcpack_theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="tvm.relax.block_builder" href="block_builder.html" />
    <link rel="prev" title="tvm.relax" href="relax.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    
<header class="header">
    <div class="innercontainer">
      <div class="headerInner d-flex justify-content-between align-items-center">
          <div class="headerLogo">
          </div>

          <div id="headMenu" class="headerNav">
            <button type="button" id="closeHeadMenu" class="navCloseBtn"><img src="../../../_static/img/close-icon.svg" alt="Close"></button>
             <ul class="nav">
                <li class="nav-item">
                   <a class="nav-link" href=https://github.com/apache/tvm/tree/unity/>Github</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://mlc.ai/mlc-llm/>MLC-LLM</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://mlc.ai/>MLC-Tutorial</a>
                </li>
             </ul>
               <div class="responsivetlcdropdown">
                 <button type="button" class="btn-link">
                   ASF
                 </button>
                 <ul>
                     <li>
                       <a href=https://apache.org/>Apache Homepage</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/licenses/>License</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/security/>Security</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/thanks.html>Thanks</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/events/current-event>Events</a>
                     </li>
                 </ul>
               </div>
          </div>
            <div class="responsiveMenuIcon">
              <button type="button" id="menuBtn" class="btn-menu"><img src="../../../_static/img/menu-icon.svg" alt="Menu Icon"></button>
            </div>

            <div class="tlcDropdown">
              <div class="dropdown">
                <button type="button" class="btn-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  ASF
                </button>
                <div class="dropdown-menu dropdown-menu-right">
                  <ul>
                     <li>
                       <a href=https://apache.org/>Apache Homepage</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/licenses/>License</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/security/>Security</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/thanks.html>Thanks</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/events/current-event>Events</a>
                     </li>
                  </ul>
                </div>
              </div>
          </div>
       </div>
    </div>
 </header>
 
    <nav data-toggle="wy-nav-shift" class="wy-nav-side fixed">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
                <div class="version">
                  0.14.dev0
                </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/install.html">Installing Apache TVM Unity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/tutorials/quick_start.html">Quick Start</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deep Dive</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../deep_dive/tensor_ir/index.html">TensorIR</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../error.html">tvm.error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ir.html">tvm.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../instrument.html">tvm.instrument</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform.html">tvm.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">tvm.target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/runtime.html">tvm.runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/ndarray.html">tvm.runtime.ndarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/relax_vm.html">tvm.runtime.relax_vm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/disco.html">tvm.runtime.disco</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/profiling.html">tvm.runtime.profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../te.html">tvm.te</a></li>
<li class="toctree-l2"><a class="reference internal" href="../topi.html">tvm.topi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/tir.html">tvm.tir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/analysis.html">tvm.tir.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/schedule.html">tvm.tir.schedule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/stmt_functor.html">tvm.tir.stmt_functor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir/transform.html">tvm.tir.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../meta_schedule.html">tvm.meta_schedule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dlight.html">tvm.dlight</a></li>
<li class="toctree-l2"><a class="reference internal" href="relax.html">tvm.relax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">tvm.relax.analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.BaseCheckResult"><code class="docutils literal notranslate"><span class="pre">BaseCheckResult</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Binding"><code class="docutils literal notranslate"><span class="pre">Binding</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Block"><code class="docutils literal notranslate"><span class="pre">Block</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Buffer"><code class="docutils literal notranslate"><span class="pre">Buffer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Buffer.access_ptr"><code class="docutils literal notranslate"><span class="pre">Buffer.access_ptr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Buffer.get_flattened_buffer"><code class="docutils literal notranslate"><span class="pre">Buffer.get_flattened_buffer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Buffer.offset_of"><code class="docutils literal notranslate"><span class="pre">Buffer.offset_of()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Buffer.scope"><code class="docutils literal notranslate"><span class="pre">Buffer.scope()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Buffer.vload"><code class="docutils literal notranslate"><span class="pre">Buffer.vload()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Buffer.vstore"><code class="docutils literal notranslate"><span class="pre">Buffer.vstore()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Call"><code class="docutils literal notranslate"><span class="pre">Call</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.DataflowBlock"><code class="docutils literal notranslate"><span class="pre">DataflowBlock</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Expr"><code class="docutils literal notranslate"><span class="pre">Expr</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.FuncStructInfo"><code class="docutils literal notranslate"><span class="pre">FuncStructInfo</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.FuncStructInfo.opaque_func"><code class="docutils literal notranslate"><span class="pre">FuncStructInfo.opaque_func()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Function"><code class="docutils literal notranslate"><span class="pre">Function</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Function.bind_params"><code class="docutils literal notranslate"><span class="pre">Function.bind_params()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Function.bind_symbolic_vars"><code class="docutils literal notranslate"><span class="pre">Function.bind_symbolic_vars()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Function.create_empty"><code class="docutils literal notranslate"><span class="pre">Function.create_empty()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.GlobalVar"><code class="docutils literal notranslate"><span class="pre">GlobalVar</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.GlobalVar.astext"><code class="docutils literal notranslate"><span class="pre">GlobalVar.astext()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.IRModule"><code class="docutils literal notranslate"><span class="pre">IRModule</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.astext"><code class="docutils literal notranslate"><span class="pre">IRModule.astext()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.from_expr"><code class="docutils literal notranslate"><span class="pre">IRModule.from_expr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.get_attr"><code class="docutils literal notranslate"><span class="pre">IRModule.get_attr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.get_constructor"><code class="docutils literal notranslate"><span class="pre">IRModule.get_constructor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.get_global_type_var"><code class="docutils literal notranslate"><span class="pre">IRModule.get_global_type_var()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.get_global_type_vars"><code class="docutils literal notranslate"><span class="pre">IRModule.get_global_type_vars()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.get_global_var"><code class="docutils literal notranslate"><span class="pre">IRModule.get_global_var()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.get_global_vars"><code class="docutils literal notranslate"><span class="pre">IRModule.get_global_vars()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.update"><code class="docutils literal notranslate"><span class="pre">IRModule.update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.update_func"><code class="docutils literal notranslate"><span class="pre">IRModule.update_func()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.update_global_info"><code class="docutils literal notranslate"><span class="pre">IRModule.update_global_info()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.with_attr"><code class="docutils literal notranslate"><span class="pre">IRModule.with_attr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.with_attrs"><code class="docutils literal notranslate"><span class="pre">IRModule.with_attrs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IRModule.without_attr"><code class="docutils literal notranslate"><span class="pre">IRModule.without_attr()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.IndexMap"><code class="docutils literal notranslate"><span class="pre">IndexMap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.from_func"><code class="docutils literal notranslate"><span class="pre">IndexMap.from_func()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.from_func_with_separators"><code class="docutils literal notranslate"><span class="pre">IndexMap.from_func_with_separators()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.inverse"><code class="docutils literal notranslate"><span class="pre">IndexMap.inverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.is_equivalent_to"><code class="docutils literal notranslate"><span class="pre">IndexMap.is_equivalent_to()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.map_indices"><code class="docutils literal notranslate"><span class="pre">IndexMap.map_indices()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.map_ndarray"><code class="docutils literal notranslate"><span class="pre">IndexMap.map_ndarray()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.map_shape"><code class="docutils literal notranslate"><span class="pre">IndexMap.map_shape()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.IndexMap.non_surjective_inverse"><code class="docutils literal notranslate"><span class="pre">IndexMap.non_surjective_inverse()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.IntEnum"><code class="docutils literal notranslate"><span class="pre">IntEnum</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.PrimFunc"><code class="docutils literal notranslate"><span class="pre">PrimFunc</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.PrimFunc.specialize"><code class="docutils literal notranslate"><span class="pre">PrimFunc.specialize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.PrimFunc.with_body"><code class="docutils literal notranslate"><span class="pre">PrimFunc.with_body()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.StructInfo"><code class="docutils literal notranslate"><span class="pre">StructInfo</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.StructInfo.is_base_of"><code class="docutils literal notranslate"><span class="pre">StructInfo.is_base_of()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.StructInfo.same_as"><code class="docutils literal notranslate"><span class="pre">StructInfo.same_as()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Type"><code class="docutils literal notranslate"><span class="pre">Type</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Type.same_as"><code class="docutils literal notranslate"><span class="pre">Type.same_as()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.Var"><code class="docutils literal notranslate"><span class="pre">Var</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tvm.relax.analysis.Var.name_hint"><code class="docutils literal notranslate"><span class="pre">Var.name_hint</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.all_global_vars"><code class="docutils literal notranslate"><span class="pre">all_global_vars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.all_vars"><code class="docutils literal notranslate"><span class="pre">all_vars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.bound_vars"><code class="docutils literal notranslate"><span class="pre">bound_vars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.contains_impure_call"><code class="docutils literal notranslate"><span class="pre">contains_impure_call()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.defined_symbolic_vars"><code class="docutils literal notranslate"><span class="pre">defined_symbolic_vars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.derive_call_ret_struct_info"><code class="docutils literal notranslate"><span class="pre">derive_call_ret_struct_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.detect_recursion"><code class="docutils literal notranslate"><span class="pre">detect_recursion()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.erase_to_well_defined"><code class="docutils literal notranslate"><span class="pre">erase_to_well_defined()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.estimate_memory_usage"><code class="docutils literal notranslate"><span class="pre">estimate_memory_usage()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.free_symbolic_vars"><code class="docutils literal notranslate"><span class="pre">free_symbolic_vars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.free_vars"><code class="docutils literal notranslate"><span class="pre">free_vars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.get_static_type"><code class="docutils literal notranslate"><span class="pre">get_static_type()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.get_var2val"><code class="docutils literal notranslate"><span class="pre">get_var2val()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.has_reshape_pattern"><code class="docutils literal notranslate"><span class="pre">has_reshape_pattern()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.name_to_binding"><code class="docutils literal notranslate"><span class="pre">name_to_binding()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.post_order_visit"><code class="docutils literal notranslate"><span class="pre">post_order_visit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.remove_all_unused"><code class="docutils literal notranslate"><span class="pre">remove_all_unused()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.struct_info_base_check"><code class="docutils literal notranslate"><span class="pre">struct_info_base_check()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.struct_info_lca"><code class="docutils literal notranslate"><span class="pre">struct_info_lca()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.suggest_layout_transforms"><code class="docutils literal notranslate"><span class="pre">suggest_layout_transforms()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.tir_vars_in_struct_info"><code class="docutils literal notranslate"><span class="pre">tir_vars_in_struct_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.udchain"><code class="docutils literal notranslate"><span class="pre">udchain()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#tvm.relax.analysis.well_formed"><code class="docutils literal notranslate"><span class="pre">well_formed()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="block_builder.html">tvm.relax.block_builder</a></li>
<li class="toctree-l2"><a class="reference internal" href="frontend.html">tvm.relax.frontend</a></li>
<li class="toctree-l2"><a class="reference internal" href="op.html">tvm.relax.op</a></li>
<li class="toctree-l2"><a class="reference internal" href="transform.html">tvm.relax.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rpc.html">tvm.rpc</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      
      <nav class="wy-nav-top" aria-label="top navigation" data-toggle="wy-nav-top">
        
            <div class="togglemenu">

            </div>
            <div class="nav-content">
              <!-- Apache TVM Unity -->
              Table of Contents
            </div>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        

          




















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> <span class="br-arrow">></span></li>
        
          <li><a href="../index.html">API Reference</a> <span class="br-arrow">></span></li>
        
      <li>tvm.relax.analysis</li>
    
    
      
      
        
      
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/mlc-ai/docs/edit/main/docs/reference/api/relax/analysis.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="module-tvm.relax.analysis">
<span id="tvm-relax-analysis"></span><h1>tvm.relax.analysis<a class="headerlink" href="#module-tvm.relax.analysis" title="Permalink to this heading">¶</a></h1>
<p>Relax IR analysis.</p>
<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.BaseCheckResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">BaseCheckResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.BaseCheckResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Return result of fine-grained base check.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Base check comes with fine-grained fail levels.</p>
<ul class="simple">
<li><p>FAIL_L0: The lhs and rhs have no intersection at all.</p></li>
<li><p>FAIL_L1: We get the failure by looking at static information.</p></li>
<li><p>FAIL_L2: We get the failure due to unknown symbolic variable relations.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.Binding">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Binding</span></span><a class="headerlink" href="#tvm.relax.analysis.Binding" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class of a binding in Relax.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.Block">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iter_vars</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.IterVar" title="tvm.tir.expr.IterVar"><span class="pre">IterVar</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.BufferRegion" title="tvm.tir.stmt.BufferRegion"><span class="pre">BufferRegion</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">writes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.BufferRegion" title="tvm.tir.stmt.BufferRegion"><span class="pre">BufferRegion</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name_hint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.stmt.Stmt"><span class="pre">Stmt</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.stmt.Stmt"><span class="pre">Stmt</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alloc_buffers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.buffer.Buffer"><span class="pre">Buffer</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_buffers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.MatchBufferRegion" title="tvm.tir.stmt.MatchBufferRegion"><span class="pre">MatchBufferRegion</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../runtime/runtime.html#tvm.runtime.Object" title="tvm.runtime.object.Object"><span class="pre">Object</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Block" title="Permalink to this definition">¶</a></dt>
<dd><p>Block node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iter_vars</strong> (<em>List</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.IterVar" title="tvm.tir.IterVar"><em>IterVar</em></a><em>]</em>) – The block Variable.</p></li>
<li><p><strong>reads</strong> (<em>List</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.BufferRegion" title="tvm.tir.BufferRegion"><em>BufferRegion</em></a><em>]</em>) – The read buffer regions of the block.</p></li>
<li><p><strong>writes</strong> (<em>List</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.BufferRegion" title="tvm.tir.BufferRegion"><em>BufferRegion</em></a><em>]</em>) – The write buffer regions of the block.</p></li>
<li><p><strong>name_hint</strong> (<em>str</em>) – the name_hint of the block.</p></li>
<li><p><strong>body</strong> (<a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><em>Stmt</em></a>) – The body of the block.</p></li>
<li><p><strong>init</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><em>Stmt</em></a><em>]</em>) – The init block of the reduction block</p></li>
<li><p><strong>alloc_buffers</strong> (<em>Optional</em><em>[</em><em>list</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.Buffer" title="tvm.relax.analysis.Buffer"><em>Buffer</em></a><em>]</em><em>]</em>) – The buffer allocations</p></li>
<li><p><strong>match_buffers</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.MatchBufferRegion" title="tvm.tir.MatchBufferRegion"><em>MatchBufferRegion</em></a><em>]</em><em>]</em>) – The subregion buffer match</p></li>
<li><p><strong>annotations</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="op.html#tvm.relax.op.Object" title="tvm.relax.op.Object"><em>Object</em></a><em>]</em><em>]</em>) – Additional annotation hints.</p></li>
<li><p><strong>span</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.Span"><em>Span</em></a><em>]</em>) – The location of this block in the source code.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.Buffer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Buffer</span></span><a class="headerlink" href="#tvm.relax.analysis.Buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolic data buffer in TVM.</p>
<p>Buffer provide a way to represent data layout
specialization of data structure in TVM.</p>
<p>Do not construct directly, use <code class="xref py py-func docutils literal notranslate"><span class="pre">decl_buffer()</span></code> instead.
See the documentation of <code class="xref py py-func docutils literal notranslate"><span class="pre">decl_buffer()</span></code> for more details.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">decl_buffer</span></code></dt><dd><p>Declare a buffer</p>
</dd>
</dl>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Buffer.access_ptr">
<span class="sig-name descname"><span class="pre">access_ptr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">access_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'handle'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">content_lanes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Buffer.access_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an access pointer to the head of buffer.</p>
<p>This is the recommended method to get buffer data
ptress when interacting with external functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>access_mask</strong> (<em>int</em>) – The access pattern MASK. Indicate whether the
access will read or write to the data content.</p></li>
<li><p><strong>ptr_type</strong> (<em>str</em><em>, </em><em>optional</em>) – The data type of the result pointer. Do not specify
unless we want to cast pointer to specific type.</p></li>
<li><p><strong>content_lanes</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of lanes for the data type. This value
is greater than one for vector types.</p></li>
<li><p><strong>offset</strong> (<em>Expr</em><em>, </em><em>optional</em>) – The offset of pointer. We can use it to offset by
the number of elements from the address of ptr.</p></li>
<li><p><strong>extent</strong> (<em>Expr</em><em>, </em><em>optional</em>) – The extent of pointer.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get access ptr for read</span>
<span class="n">buffer</span><span class="o">.</span><span class="n">access_ptr</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="c1"># Get access ptr for read/write with bitmask</span>
<span class="n">buffer</span><span class="o">.</span><span class="n">access_ptr</span><span class="p">(</span><span class="n">Buffer</span><span class="o">.</span><span class="n">READ</span> <span class="o">|</span> <span class="n">Buffer</span><span class="o">.</span><span class="n">WRITE</span><span class="p">)</span>
<span class="c1"># Get access ptr for read/write with str flag</span>
<span class="n">buffer</span><span class="o">.</span><span class="n">access_ptr</span><span class="p">(</span><span class="s2">&quot;rw&quot;</span><span class="p">)</span>
<span class="c1"># Get access ptr for read with offset</span>
<span class="n">buffer</span><span class="o">.</span><span class="n">access_ptr</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1"># Get access ptr for read with extent</span>
<span class="n">buffer</span><span class="o">.</span><span class="n">access_ptr</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">extent</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Buffer.get_flattened_buffer">
<span class="sig-name descname"><span class="pre">get_flattened_buffer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Buffer.get_flattened_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Buffer that is a flattened version of this buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>flattened</strong> – The corresponding flat buffer.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.relax.analysis.Buffer" title="tvm.relax.analysis.Buffer">Buffer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Buffer.offset_of">
<span class="sig-name descname"><span class="pre">offset_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Buffer.offset_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the offset of the provided indices in the flattened buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>indices</strong> (<em>Union</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>, </em><em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em><em>]</em>) – The indices of the element in the original buffer.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>flattened_indices</strong> – The offset indices of the element in the flattened buffer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Buffer.scope">
<span class="sig-name descname"><span class="pre">scope</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Buffer.scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage scope associated with this buffer.
:returns: <strong>scope</strong> – The storage scope associated with this buffer.
:rtype: str</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Buffer.vload">
<span class="sig-name descname"><span class="pre">vload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Buffer.vload" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an Expr that loads dtype from begin index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>begin</strong> (<a class="reference internal" href="../ir.html#tvm.ir.Array" title="tvm.ir.Array"><em>Array</em></a><em> of </em><em>Expr</em>) – The beginning index in unit of Buffer.dtype</p></li>
<li><p><strong>dtype</strong> (<em>str</em>) – The data type to be loaded,
can be vector type which have lanes that is multiple of Buffer.dtype</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>load</strong> – The corresponding load expression.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Buffer.vstore">
<span class="sig-name descname"><span class="pre">vstore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">begin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Buffer.vstore" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Stmt that store value into begin index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>begin</strong> (<a class="reference internal" href="../ir.html#tvm.ir.Array" title="tvm.ir.Array"><em>Array</em></a><em> of </em><em>Expr</em>) – The beginning index in unit of Buffer.dtype</p></li>
<li><p><strong>value</strong> (<em>Expr</em>) – The value to be stored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>store</strong> – The corresponding store stmt.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt">Stmt</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.Call">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.Op" title="tvm.ir.op.Op"><span class="pre">Op</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.Attrs" title="tvm.ir.attrs.Attrs"><span class="pre">Attrs</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinfo_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Call" title="Permalink to this definition">¶</a></dt>
<dd><p>Function call node in Relax.</p>
<p>relax.Call node corresponds the operator application node
in computational graph terminology.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> (<a class="reference internal" href="../ir.html#tvm.ir.Op" title="tvm.ir.Op"><em>tvm.ir.Op</em></a><em> or </em><em>any tvm.relax.Expr with function type.</em>) – The operation to be called.</p></li>
<li><p><strong>args</strong> (<em>Union</em><em>[</em><em>List</em><em>[</em><em>Expr</em><em>]</em><em>, </em><em>Tuple</em><em>[</em><em>Expr</em><em>, </em><em>...</em><em>]</em><em>]</em>) – The arguments to the call.</p></li>
<li><p><strong>attrs</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Attrs" title="tvm.ir.Attrs"><em>tvm.ir.Attrs</em></a><em>]</em>) – Attributes to the call, can be None</p></li>
<li><p><strong>sinfo_args</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>List</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a><em>]</em><em>, </em><em>Tuple</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a><em>, </em><em>...</em><em>]</em><em>]</em><em>]</em>) – The structure info arguments of a CallNode.
sinfo_args is designed to be non-empty only for intrinsic op (e.g.,
call_tir, call_builtin_with_ctx, etc.) and calls to ExternFuncs, with the main
usage of structure info inference.</p></li>
<li><p><strong>span</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.Span"><em>Span</em></a><em>]</em>) – Span that points to original source code</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.DataflowBlock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">DataflowBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bindings</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.analysis.Binding" title="tvm.relax.expr.Binding"><span class="pre">Binding</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.DataflowBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>dataflow block, bindings inside are pure (no side effect and no control flow)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="tvm.relax.analysis.Expr">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Expr</span></span><a class="headerlink" href="#tvm.relax.analysis.Expr" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><code class="xref py py-class docutils literal notranslate"><span class="pre">RelayExpr</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.FuncStructInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">FuncStructInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">purity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.FuncStructInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>StructInfo of a function value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>List</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a><em>]</em>) – The struct info of the fields.</p></li>
<li><p><strong>ret</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The struct info of return value</p></li>
<li><p><strong>purity</strong> (<em>bool</em>) – Whether the function is pure (has no visible side effects).
Note: We consider a function to be pure only if it is pure on all inputs.
If a function can have visible side effects only in some cases,
we still consider it impure.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.FuncStructInfo.opaque_func">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">opaque_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derive_func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.EnvFunc" title="tvm.ir.base.EnvFunc"><span class="pre">EnvFunc</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">purity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.FuncStructInfo" title="tvm.relax.struct_info.FuncStructInfo"><span class="pre">FuncStructInfo</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.FuncStructInfo.opaque_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an opaque FuncStructInfo.</p>
<p>The opaque function takes either a ret
that specificies the struct info of the return value
or a derive_func that provides a customized derivation rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ret</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a><em>]</em>) – The struct info of the the function return value.</p></li>
<li><p><strong>derive_func</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.EnvFunc" title="tvm.ir.EnvFunc"><em>EnvFunc</em></a><em>]</em>) – The environment function used for derivation</p></li>
<li><p><strong>purity</strong> (<em>bool</em>) – Whether the function is pure (false by default, as most opaque functions are not pure)</p></li>
<li><p><strong>span</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.Span"><em>Span</em></a><em>]</em>) – Optional span information of the ast.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>info</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.FuncStructInfo" title="tvm.relax.analysis.FuncStructInfo">FuncStructInfo</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We cannot specify ret and derive_func simultaneously.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.Function">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_struct_info</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_pure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.DictAttrs" title="tvm.ir.attrs.DictAttrs"><span class="pre">DictAttrs</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Function" title="Permalink to this definition">¶</a></dt>
<dd><p>A Relax function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Function.bind_params">
<span class="sig-name descname"><span class="pre">bind_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binding_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../runtime/ndarray.html#tvm.runtime.ndarray.NDArray" title="tvm.runtime.ndarray.NDArray"><span class="pre">NDArray</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.Function.bind_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new function with updated symbolic variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>binding_map</strong> (<em>Mapping</em><em>[</em>) – <dl class="simple">
<dt>Union[str, relax.Var],</dt><dd><p>Union[int, float, PrimExpr, tvm.runtime.NDArray, _np.ndarray, Expr],</p>
</dd>
</dl>
<p>]</p>
<p>The mapping of values to be replaced.</p>
<p>Keys may be either a <cite>relax.Var</cite> or a string name of the
Relax variable.  If the variables are referred to by name,
the name must uniquely identify a parameter in the
function.</p>
<p>Values must be a relax expression, or a value that is
convertible into a relax expression.  The value must be
compatible with the variable being replaced.</p>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>func</strong> – The updated function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function">Function</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Function.bind_symbolic_vars">
<span class="sig-name descname"><span class="pre">bind_symbolic_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binding_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.Function.bind_symbolic_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new function with updated symbolic variable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>binding_map</strong> (<em>Mapping</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.Var"><em>tvm.tir.Var</em></a><em>]</em><em>, </em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – The mapping of values to be replaced.  Keys may be either
a <cite>tir.Var</cite> or a string name of the variable.  If the
variables are referred to by name, the name must uniquely
identify a symbolic variable in the function.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>func</strong> – The updated function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function">Function</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Function.create_empty">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_struct_info</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_pure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.DictAttrs" title="tvm.ir.attrs.DictAttrs"><span class="pre">DictAttrs</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Function.create_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a relax.Function but without body</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.GlobalVar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">GlobalVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_hint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_annot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.GlobalVar" title="Permalink to this definition">¶</a></dt>
<dd><p>A global variable in the IR.</p>
<p>GlobalVar is used to refer to the global functions
stored in the IRModule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name_hint</strong> (<em>str</em>) – The name of the variable.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.GlobalVar.astext">
<span class="sig-name descname"><span class="pre">astext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">show_meta_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.GlobalVar.astext" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the text format of the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>show_meta_data</strong> (<em>bool</em>) – Whether to include meta data section in the text
if there is meta data.</p></li>
<li><p><strong>annotate</strong> (<em>Optional</em><em>[</em><em>Object-&gt;str</em><em>]</em>) – Optionally annotate function to provide additional
information in the comment block.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>text</strong> – The text format of the expression.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The meta data section is necessary to fully parse the text format.
However, it can contain dumps that are big (e.g constant weights),
so it can be helpful to skip printing the meta data section.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">IRModule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">functions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_definitions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_infos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule" title="Permalink to this definition">¶</a></dt>
<dd><p>IRModule that holds functions and type definitions.</p>
<p>IRModule is the basic unit for all IR transformations across the stack.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>functions</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em><em>.</em>) – Map of global var to BaseFunc</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.astext">
<span class="sig-name descname"><span class="pre">astext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">show_meta_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.astext" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the text format of the expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>show_meta_data</strong> (<em>bool</em>) – Whether to include meta data section in the text
if there is meta data.</p></li>
<li><p><strong>annotate</strong> (<em>Optional</em><em>[</em><em>Object-&gt;str</em><em>]</em>) – Optionally annotate function to provide additional
information in the comment block.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>text</strong> – The text format of the expression.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The meta data section is necessary to fully parse the text format.
However, it can contain dumps that are big (e.g constant weights),
so it can be helpful to skip printing the meta data section.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.from_expr">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_expr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">functions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_defs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.from_expr" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a module from a standalone expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.RelayExpr"><em>RelayExpr</em></a>) – The starting expression</p></li>
<li><p><strong>global_funcs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – Map of global vars to function definitions</p></li>
<li><p><strong>type_defs</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – Map of global type vars to type definitions</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mod</strong> – A module containing the passed definitions,
where expr is set as the entry point
(wrapped in a function if necessary)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../runtime/runtime.html#tvm.runtime.Module" title="tvm.runtime.Module">Module</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.get_attr">
<span class="sig-name descname"><span class="pre">get_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr_key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.get_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the IRModule attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>attr_key</strong> (<em>str</em>) – The attribute key.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>attr_value</strong> – Attribute value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../tir/tir.html#tvm.tir.Any" title="tvm.tir.Any">Any</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.get_constructor">
<span class="sig-name descname"><span class="pre">get_constructor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.get_constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up an ADT constructor by tag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tag</strong> (<em>int</em>) – The tag for a constructor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>constructor</strong> – The constructor associated with the given tag,</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../ir.html#tvm.ir.Constructor" title="tvm.ir.Constructor">Constructor</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>tvm.error.TVMError if the corresponding constructor cannot be found.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.get_global_type_var">
<span class="sig-name descname"><span class="pre">get_global_type_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.get_global_type_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a global type variable in the function by name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – The name of the global type variable.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>global_type_var</strong> – The global variable mapped to <code class="code docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../ir.html#tvm.ir.GlobalTypeVar" title="tvm.ir.GlobalTypeVar">GlobalTypeVar</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>tvm.error.TVMError if we cannot find corresponding global type var.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.get_global_type_vars">
<span class="sig-name descname"><span class="pre">get_global_type_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.get_global_type_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all global type vars defined in this module.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>global_type_vars</strong> – An array of global type vars.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../ir.html#tvm.ir.Array" title="tvm.ir.Array">Array</a>[<a class="reference internal" href="../ir.html#tvm.ir.GlobalTypeVar" title="tvm.ir.GlobalTypeVar">GlobalTypeVar</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.get_global_var">
<span class="sig-name descname"><span class="pre">get_global_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.get_global_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a global variable in the function by name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – The name of the global variable.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>global_var</strong> – The global variable mapped to <code class="code docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.GlobalVar" title="tvm.relax.analysis.GlobalVar">GlobalVar</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>tvm.error.TVMError if we cannot find corresponding global var.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.get_global_vars">
<span class="sig-name descname"><span class="pre">get_global_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.get_global_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all global vars defined in this module.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>global_vars</strong> – An array of global vars.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../ir.html#tvm.ir.Array" title="tvm.ir.Array">Array</a>[<a class="reference internal" href="#tvm.relax.analysis.GlobalVar" title="tvm.relax.analysis.GlobalVar">GlobalVar</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert functions in another Module to current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.relax.analysis.IRModule"><em>IRModule</em></a>) – The module to merge into the current Module.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.update_func">
<span class="sig-name descname"><span class="pre">update_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.update_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the function corresponding to a global variable in the
module.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="#tvm.relax.analysis.GlobalVar" title="tvm.relax.analysis.GlobalVar"><em>GlobalVar</em></a>) – The global variable.</p></li>
<li><p><strong>func</strong> (<em>tvm.relay.Function</em>) – The function to be inserted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.update_global_info">
<span class="sig-name descname"><span class="pre">update_global_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.update_global_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Update global info in the module</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – The name for the global info.</p></li>
<li><p><strong>global_info</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.GlobalInfo" title="tvm.ir.GlobalInfo"><em>GlobalInfo</em></a><em>]</em>) – The global info to be updated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.with_attr">
<span class="sig-name descname"><span class="pre">with_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr_key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attr_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IRModule.with_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the IRModule and add an attribute to it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attr_key</strong> (<em>str</em>) – The attribute key.</p></li>
<li><p><strong>attr_value</strong> (<a class="reference internal" href="op.html#tvm.relax.op.Object" title="tvm.relax.op.Object"><em>Object</em></a>) – The new attribute value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mod</strong> – A new copy of the IRModule with the attribute</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.relax.analysis.IRModule">IRModule</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.with_attrs">
<span class="sig-name descname"><span class="pre">with_attrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.DictAttrs" title="tvm.ir.attrs.DictAttrs"><span class="pre">DictAttrs</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../runtime/runtime.html#tvm.runtime.Object" title="tvm.runtime.object.Object"><span class="pre">Object</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.relax.analysis.IRModule"><span class="pre">IRModule</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.IRModule.with_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the IRModule and add the given attribute map to it.
:param attr_map: The attribute map
:type attr_map: Union[DictAttrs, Dict[str, Object]]</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mod</strong> – A new copy of the IRModule with the attribute</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.relax.analysis.IRModule">IRModule</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IRModule.without_attr">
<span class="sig-name descname"><span class="pre">without_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr_key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.relax.analysis.IRModule"><span class="pre">IRModule</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.IRModule.without_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the IRModule and remove an attribute key and its associated value.
:param attr_key: The attribute key.
:type attr_key: str</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mod</strong> – A new copy of the IRModule without the attribute</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.relax.analysis.IRModule">IRModule</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">IndexMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_index_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IndexMap" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from multi-dimensional indices to another set of multi-dimensional indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_indices</strong> (<em>List</em><em>[</em><em>relax.Var</em><em>]</em>) – Variables representing the indices prior to remapping.</p></li>
<li><p><strong>final_indices</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – Expressions defining the indices after remapping.</p></li>
<li><p><strong>inverse_index_map</strong> (<em>Union</em><em>[</em><em>Callable</em><em>, </em><em>Optional</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap"><em>IndexMap</em></a><em>]</em><em>]</em>) – The optional pre-defined inverse index map.
When this is defined, IndexMap::Inverse will return the pre-defined inverse index map.
Otherwise, the inverse index map will be computed on the fly.
It is the user’s responsibility to ensure the correctness of the pre-defined inverse
index map.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.from_func">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'int64'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.from_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an index map from a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mapping_function</strong> (<em>Callable</em>) – The function to map from source indices to target indices.
The function should accept <cite>tir.Var</cite> parameters and return
a either a <cite>tir.PrimExpr</cite>, or a list of <cite>tir.PrimExpr</cite>.
Returning a <cite>tir.PrimExpr</cite> is equivalent to returning a
list of length 1 containing that <cite>tir.PrimExpr</cite>.</p></li>
<li><p><strong>ndim</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The dimensionality of the buffer to which this
transformation should be applied.  If mapping_function uses
variadic argument <cite>*args</cite>, <cite>ndim</cite> must be specified.  If
mapping_function does not use variadic arguments, ndim is
optional.</p></li>
<li><p><strong>inverse_index_map</strong> (<em>Union</em><em>[</em><em>Callable</em><em>, </em><em>Optional</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap"><em>IndexMap</em></a><em>]</em><em>]</em>) – The optional pre-defined inverse index map.
When this is defined, IndexMap::Inverse will return the pre-defined inverse index map.
Otherwise, the inverse index map will be computed on the fly.
It is the user’s responsibility to ensure the correctness of the pre-defined inverse
index map.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index_map</strong> – Returns an IndexMap representing the <cite>mapping_function</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap">IndexMap</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.from_func_with_separators">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_func_with_separators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_index_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'int64'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.from_func_with_separators" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an index map from a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mapping_function</strong> (<em>Callable</em>) – The function to map from source indices to target indices.
The function should accept tir.Var parameters and return
either a <cite>tir.PrimExpr</cite> or a list.  Each element of the
returned list should be either a <cite>tir.PrimExpr</cite> or the
object <cite>IndexMap.AXIS_SEPARATOR</cite>.  Returning a
<cite>tir.PrimExpr</cite> is equivalent to returning a list of length
1 containing that <cite>tir.PrimExpr</cite>.</p></li>
<li><p><strong>ndim</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The dimensionality of the buffer to which this
transformation should be applied.  If mapping_function uses
variadic argument <cite>*args</cite>, ndim must be specified.  If
mapping_function does not use variadic arguments, ndim is
optional.</p></li>
<li><p><strong>inverse_index_map</strong> (<em>Union</em><em>[</em><em>Callable</em><em>, </em><em>Optional</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap"><em>IndexMap</em></a><em>]</em><em>]</em>) – The optional pre-defined inverse index map.
When this is defined, IndexMap::Inverse will return the pre-defined inverse index map.
Otherwise, the inverse index map will be computed on the fly.
It is the user’s responsibility to ensure the correctness of the pre-defined inverse
index map.</p></li>
<li><p><strong>index_dtype</strong> (<em>str</em>) – The default index dtype to use for input iters in the mapping function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – Returns a tuple whose first element is an IndexMap
representing the <cite>mapping_function</cite>, and whose second index
is a list of indices at which <cite>IndexMap.AXIS_SEPARATOR</cite>
occurred.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap">IndexMap</a>, List[int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.expr.Range"><span class="pre">Range</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of the map</p>
<p>Throws an error if the function is not bijective.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.Range"><em>Range</em></a><em>,</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em><em>]</em>) – The region over which the inverse should be determined.
Used for validating that the mapping is bijective over
this range.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>inverse</strong> – The inverse</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap">IndexMap</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.is_equivalent_to">
<span class="sig-name descname"><span class="pre">is_equivalent_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.is_equivalent_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index maps are equivalent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other_map</strong> (<a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap"><em>IndexMap</em></a>) – The IndexMap to which the comparison should be made.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>is_equivalent</strong> – True if the two mappings represent the same
transformation, otherwise False</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.map_indices">
<span class="sig-name descname"><span class="pre">map_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.map_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the index map to a set of indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>indices</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – The indices to be mapped</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The mapped indices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.map_ndarray">
<span class="sig-name descname"><span class="pre">map_ndarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_src</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../runtime/ndarray.html#tvm.runtime.ndarray.NDArray" title="tvm.runtime.ndarray.NDArray"><span class="pre">NDArray</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../runtime/ndarray.html#tvm.runtime.ndarray.NDArray" title="tvm.runtime.ndarray.NDArray"><span class="pre">NDArray</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.map_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply thie index map to transform the layout of the input NDArray</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>arr_src</strong> (<em>runtime.NDArray</em>) – The NDArray to be transformed</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>arr_dst</strong> – The transformed NDArray</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>runtime.NDArray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.map_shape">
<span class="sig-name descname"><span class="pre">map_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.map_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the index map to a buffer shape</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>List</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em>) – The buffer shape to be mapped</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The mapped shape</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.IndexMap.non_surjective_inverse">
<span class="sig-name descname"><span class="pre">non_surjective_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.expr.Range"><span class="pre">Range</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.IndexMap.non_surjective_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of the map</p>
<p>Can be applied to transformations that introduce padding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Range" title="tvm.ir.Range"><em>Range</em></a><em>,</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>]</em><em>]</em>) – The region over which the inverse should be determined.
Used for determining the predicate.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The inverse, and a predicate for which the inverse maps to
a valid index in the input range.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap">IndexMap</a>, <a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr">PrimExpr</a>]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">index_map</span> <span class="o">=</span> <span class="n">IndexMap</span><span class="o">.</span><span class="n">from_func</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span> <span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="p">])</span>
<span class="n">inverse_map</span><span class="p">,</span> <span class="n">predicate</span> <span class="o">=</span> <span class="n">index_map</span><span class="o">.</span><span class="n">non_surjective_inverse</span><span class="p">([</span><span class="mi">14</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">inverse_map</span><span class="o">.</span><span class="n">is_equivalent_to</span><span class="p">(</span><span class="n">IndexMap</span><span class="o">.</span><span class="n">from_func</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span> <span class="c1"># Prints &quot;(axis0==3) &amp;&amp; (axis2 &gt;= 2)&quot;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.IntEnum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">IntEnum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.IntEnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Enum where members are also (and must be) ints</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.PrimFunc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">PrimFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">body</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.PrimFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>A function declaration expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.Var"><em>tvm.tir.Var</em></a><em>, </em><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><em>tvm.tir.Buffer</em></a><em>]</em><em>]</em>) – List of input parameters to the function.</p></li>
<li><p><strong>body</strong> (<a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><em>tvm.tir.Stmt</em></a>) – The body of the function.</p></li>
<li><p><strong>ret_type</strong> (<a class="reference internal" href="../ir.html#tvm.ir.Type" title="tvm.ir.Type"><em>tvm.ir.Type</em></a>) – The return type annotation of the function.</p></li>
<li><p><strong>buffer_map</strong> (<a class="reference internal" href="../ir.html#tvm.ir.Map" title="tvm.ir.Map"><em>Map</em></a><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.Var"><em>tvm.tir.Var</em></a><em>, </em><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.Buffer"><em>tvm.tir.Buffer</em></a><em>]</em>) – The buffer binding map.</p></li>
<li><p><strong>attrs</strong> (<em>Optional</em><em>[</em><em>tvm.Attrs</em><em>]</em>) – Attributes of the function, can be None</p></li>
<li><p><strong>span</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.Span"><em>Span</em></a><em>]</em>) – The location of this itervar in the source code.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.PrimFunc.specialize">
<span class="sig-name descname"><span class="pre">specialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Mapping</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.buffer.Buffer"><span class="pre">Buffer</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.PrimFunc.specialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialize parameters of PrimFunc</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param_map</strong> (<em>Mapping</em><em>[</em><em>relax.Var</em><em>, </em><em>Union</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.PrimExpr" title="tvm.ir.PrimExpr"><em>PrimExpr</em></a><em>, </em><a class="reference internal" href="#tvm.relax.analysis.Buffer" title="tvm.relax.analysis.Buffer"><em>Buffer</em></a><em>]</em><em>]</em>) – The mapping from function params to the instance</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We can define a Meta TIR function with symbolic shape:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@T</span><span class="o">.</span><span class="n">prim_func</span>
<span class="k">def</span> <span class="nf">mem_copy</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">T</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="n">vi</span><span class="p">,</span> <span class="n">vj</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="s2">&quot;SS&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">B</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span>
</pre></div>
</div>
<p>Then we can make it specialized with given shapes or buffers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mem_copy</span><span class="o">.</span><span class="n">params</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">mem_copy</span><span class="o">.</span><span class="n">specialize</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="n">tir</span><span class="o">.</span><span class="n">decl_buffer</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))})</span>
<span class="c1"># or</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">mem_copy</span><span class="o">.</span><span class="n">specialize</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="mi">16</span><span class="p">})</span>
</pre></div>
</div>
<p>The specialized function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@T</span><span class="o">.</span><span class="n">prim_func</span>
<span class="k">def</span> <span class="nf">mem_copy_16_16</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">T</span><span class="o">.</span><span class="n">handle</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">match_buffer</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">T</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="n">vi</span><span class="p">,</span> <span class="n">vj</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="s2">&quot;SS&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">B</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> – The new function with parameter specialized</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.relax.analysis.PrimFunc" title="tvm.relax.analysis.PrimFunc">PrimFunc</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.PrimFunc.with_body">
<span class="sig-name descname"><span class="pre">with_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_body</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.PrimFunc.with_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new PrimFunc with the same set signatures but a new body.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_body</strong> (<a class="reference internal" href="../tir/tir.html#tvm.tir.Stmt" title="tvm.tir.Stmt"><em>Stmt</em></a>) – The new body.</p></li>
<li><p><strong>span</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.Span"><em>Span</em></a><em>]</em>) – The location of this itervar in the source code.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>new_func</strong> – The created new function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.PrimFunc" title="tvm.relax.analysis.PrimFunc">PrimFunc</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.StructInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">StructInfo</span></span><a class="headerlink" href="#tvm.relax.analysis.StructInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class of all StructInfo.</p>
<p>StructInfo contains both the static type
and runtime structural information.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.StructInfo.is_base_of">
<span class="sig-name descname"><span class="pre">is_base_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">derived</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#tvm.relax.analysis.StructInfo.is_base_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self is base of another derived struct info.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>derived</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The derived struct info to be checked.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The check result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.StructInfo.same_as">
<span class="sig-name descname"><span class="pre">same_as</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.StructInfo.same_as" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload with structural equality.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.Type">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Type</span></span><a class="headerlink" href="#tvm.relax.analysis.Type" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class of all types.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tvm.relax.analysis.Type.same_as">
<span class="sig-name descname"><span class="pre">same_as</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Type.same_as" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two Relay types by referential equality.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="tvm.relax.analysis.Var">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">Var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_hint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Id</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">struct_info</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">span</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../ir.html#tvm.ir.Span" title="tvm.ir.base.Span"><span class="pre">Span</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.Var" title="Permalink to this definition">¶</a></dt>
<dd><p>The variable class for all Relax bindings.</p>
<dl class="py property">
<dt class="sig sig-object py" id="tvm.relax.analysis.Var.name_hint">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name_hint</span></span><a class="headerlink" href="#tvm.relax.analysis.Var.name_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Get name hint of the current var.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.all_global_vars">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">all_global_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.GlobalVar" title="tvm.ir.expr.GlobalVar"><span class="pre">GlobalVar</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.all_global_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all global variables from expression expr.
:param expr: The expression.
:type expr: Expr</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – List of global vars in expr, in post-DFS order</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>List[<a class="reference internal" href="#tvm.relax.analysis.GlobalVar" title="tvm.relax.analysis.GlobalVar">GlobalVar</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.all_vars">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">all_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.all_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all (local) variables from expression expr.
:param expr: The expression.
:type expr: Expr</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – List of vars in expr, in post-DFS order</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>List[relax.Var]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.bound_vars">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">bound_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.bound_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all bound variables from expression expr.
Bound variables are all variables that are declared in the expr.
They only have meaning inside that expr, and can only be used in it.
:param expr: The expression.
:type expr: Expr</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – List of bound vars in expr, in post-DFS order</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>List[relax.Var]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.contains_impure_call">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">contains_impure_call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">own_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.GlobalVar" title="tvm.ir.expr.GlobalVar"><span class="pre">GlobalVar</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#tvm.relax.analysis.contains_impure_call" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given expression (likely a function body) contains any impure calls.</p>
<dl class="simple">
<dt>expr<span class="classifier">Expr</span></dt><dd><p>The expression to be examined. If expr is a function, we check the body.</p>
</dd>
<dt>own_name<span class="classifier">relax.Var or GlobalVar (optional)</span></dt><dd><p>For a recursive function, the analysis can ignore the self-calls
for checking purity.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – True if there is an impure call
(call to a function that may have visible side effects).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Relies on StructInfo annotations, so ensure that the module has been normalized first.
Also, an impure call in a <em>nested</em> function does <em>not</em> mean that the outer expression contains
an impure call–it only does if the nested function is <em>later called</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.defined_symbolic_vars">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">defined_symbolic_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.defined_symbolic_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the TIR variables that defined in the input function.
The returned list is deduplicated - each TIR variable will appear at most once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> (<a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function"><em>Function</em></a>) – The function object to be analyzed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The list of symbolic variables that are defined in the input function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[relax.Var]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.derive_call_ret_struct_info">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">derive_call_ret_struct_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_sinfo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.FuncStructInfo" title="tvm.relax.struct_info.FuncStructInfo"><span class="pre">FuncStructInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">call</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.memory.Call" title="tvm.relax.expr.Call"><span class="pre">Call</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="block_builder.html#tvm.relax.block_builder.BlockBuilder" title="tvm.relax.block_builder.BlockBuilder"><span class="pre">BlockBuilder</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.derive_call_ret_struct_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive the call’s ret value struct info from inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func_sinfo</strong> (<a class="reference internal" href="#tvm.relax.analysis.FuncStructInfo" title="tvm.relax.analysis.FuncStructInfo"><em>FuncStructInfo</em></a>) – The call’s function signature.</p></li>
<li><p><strong>call</strong> (<em>relax.Call</em>) – The call expression</p></li>
<li><p><strong>ctx</strong> (<em>tvm.relax.BlockBuilder</em>) – The context block builder.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The derived return value struct info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo">StructInfo</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is an internal derivation function, call.op field is
ignored in this case and the derivation only depends on func_sinfo.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.detect_recursion">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">detect_recursion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mod</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.ir.module.IRModule"><span class="pre">IRModule</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="op.html#tvm.relax.op.GlobalVar" title="tvm.ir.expr.GlobalVar"><span class="pre">GlobalVar</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.detect_recursion" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all sets of recursive or mutually recursive functions in the module.</p>
<p>Two or more functions are mutually recursive if there is some cycle of references
among them. For example, if there are two functions A and B, they are
mutually recursive if A calls B and B calls A. Another case would be with
three functions A, B, and C, where A calls B, B calls C, and C calls A.</p>
<p>(Note that functions do not have to call each other to reference each other.
For example, if a function returns another function, that is still a reference
that could potentially be recursive, even without a call.)</p>
<p>If a function is simply recursive and not mutually recursive with any other,
it will be reported as a group by itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mod</strong> (<em>The module</em>) – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – Each member of the list is a list of global functions
that references each other mutually recursively.
If a function is simply recursive and not mutually recursive
with any other, it will be a singleton in this list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[List[<a class="reference internal" href="#tvm.relax.analysis.GlobalVar" title="tvm.relax.analysis.GlobalVar">GlobalVar</a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.erase_to_well_defined">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">erase_to_well_defined</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sinfo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape_var_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="op.html#tvm.relax.op.image.PrimExpr" title="tvm.ir.expr.PrimExpr"><span class="pre">PrimExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.erase_to_well_defined" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase sinfo into a well defined form.</p>
<p>This function removes the StructInfo’s dependencies on shape and vars that
are not defined in given maps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sinfo</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The input struct info.</p></li>
<li><p><strong>shape_var_map</strong> (<em>Dict</em><em>[</em><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.Var"><em>tir.Var</em></a><em>, </em><em>tir.PrimExpr</em><em>]</em>) – Specifies the defined shape vars and the values they should map to.</p></li>
<li><p><strong>var_map</strong> (<em>Dict</em><em>[</em><em>relax.Var</em><em>, </em><em>Expr</em><em>]</em>) – Specifies the defined vars and the values they should map to.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The corresponding erased struct info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo">StructInfo</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.estimate_memory_usage">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">estimate_memory_usage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mod</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.ir.module.IRModule"><span class="pre">IRModule</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#tvm.relax.analysis.estimate_memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Analysis function that estimates the memory usage of Relax functions
in an IRModule. The estimation includes the total memory size needed to
be allocated before and after memory planning.</p>
<p>The result might be over-estimated, as the estimation is static, which
does not consider control flows (such as “if” and cross-function calls).
It simply accumulates the size of every alloc_tensor and alloc_storage.</p>
<p>This analysis function is used to demonstrate the effect of memory
planning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mod</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.relax.analysis.IRModule"><em>IRModule</em></a><em>, </em><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function"><em>Function</em></a><em>]</em>) – The input IRModule whose functions inside are to be analyzed.
If the input is a Function, we will wrap it with a IRModule, with
the function named “main”.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>est</strong> – The estimation information, in the form of a string.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We regards “relax.memory.alloc_tensor/storage” as the results produced by memory planning.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.free_symbolic_vars">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">free_symbolic_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.free_symbolic_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the TIR variables that are used but not defined in the input function.
The returned list is deduplicated - each TIR variable will appear at most once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> (<a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function"><em>Function</em></a>) – The function object to be analyzed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The list of symbolic variables that are used but not defined in the input function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[relax.Var]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.free_vars">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">free_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.free_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all free variables from expression expr.
Free variables are variables that are not bound by a
VarBinding or a function parameter in the expression.
:param expr: The expression.
:type expr: Expr</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ret</strong> – List of free vars in expr, in post-DFS order</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>List[relax.Var]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.get_static_type">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">get_static_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sinfo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.Type" title="tvm.ir.type.Type"><span class="pre">Type</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.get_static_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the corresponding static type from a StructInfo.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sinfo</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The input struct info.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The corresponding static type.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.Type" title="tvm.relax.analysis.Type">Type</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.get_var2val">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">get_var2val</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../ir.html#tvm.ir.RelayExpr" title="tvm.ir.expr.RelayExpr"><span class="pre">RelayExpr</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.get_var2val" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a mapping from relax.Var to Expr for each variable in the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> (<a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function"><em>Function</em></a>) – The input function to be analyzed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A mapping from relax.Var to Expr.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[relax.Var, Expr]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.has_reshape_pattern">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">has_reshape_pattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../tir/tir.html#tvm.tir.PrimFunc" title="tvm.tir.function.PrimFunc"><span class="pre">PrimFunc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#tvm.relax.analysis.has_reshape_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given PrimFunc is essentially doing a reshape operation.
The reshape operation also includes expand_dims, squeeze, flatten, etc.</p>
<p>Here the allowed reshape pattern is: for example, assume the operation is
<cite>B[l_0, l_1, …, l_b] = A[r_0, r_1, …, r_a]</cite>, we check if we can prove
that the flattened index of l_0, …, l_b under buffer B equals to the
flattened index of r_0, …, r_a under buffer A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> (<a class="reference internal" href="../tir/tir.html#tvm.tir.PrimFunc" title="tvm.tir.PrimFunc"><em>tir.PrimFunc</em></a>) – The function to be examined.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – A boolean indicating if the given PrimFunc is doing a reshape.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>According to the description above, the returned result can only be
false-negative and cannot be false-positive, since whenever we cannot
prove the equality, we return false. This property guarantees the safety
of this function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.name_to_binding">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">name_to_binding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#tvm.relax.analysis.Binding" title="tvm.relax.expr.Binding"><span class="pre">Binding</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.name_to_binding" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a map from variable name to its bindings.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.post_order_visit">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">post_order_visit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fvisit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relax.analysis.post_order_visit" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively visit the ir in post DFS order node,
apply fvisit. Each node is guaranteed to be visited
only once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>tvm.relay.Expr</em>) – The input expression.</p></li>
<li><p><strong>fvisit</strong> (<em>function</em>) – The visitor function to be applied.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.remove_all_unused">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">remove_all_unused</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.expr.Function"><span class="pre">Function</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.remove_all_unused" title="Permalink to this definition">¶</a></dt>
<dd><p>It removes:
1. Unused local VarBindings in a DataflowBlock.
2. Unused DataflowBlocks in a function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> (<a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function"><em>Function</em></a>) – The input function to be analyzed.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For IRModule-wise DCE, use py:func:<cite>tvm.relax.transform.DeadCodeElimination</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The function with unused variables removed.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#tvm.relax.analysis.Function" title="tvm.relax.analysis.Function">Function</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.struct_info_base_check">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">struct_info_base_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derived</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#tvm.relax.analysis.BaseCheckResult" title="tvm.relax.analysis.analysis.BaseCheckResult"><span class="pre">BaseCheckResult</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.struct_info_base_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a base check to see if base subsumes derived.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>base</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The base struct info.</p></li>
<li><p><strong>derived</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The derived struct info.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The derived return value struct info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo">StructInfo</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.struct_info_lca">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">struct_info_lca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></span><a class="headerlink" href="#tvm.relax.analysis.struct_info_lca" title="Permalink to this definition">¶</a></dt>
<dd><p>Unify the two struct info to their least common ancestor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The left operand.</p></li>
<li><p><strong>rhs</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The right operand.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The corresponding lca result.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo">StructInfo</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.suggest_layout_transforms">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">suggest_layout_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../tir/tir.html#tvm.tir.PrimFunc" title="tvm.tir.function.PrimFunc"><span class="pre">PrimFunc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">write_buffer_transforms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Block" title="tvm.tir.stmt.Block"><span class="pre">Block</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Block" title="tvm.tir.stmt.Block"><span class="pre">Block</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.Buffer" title="tvm.tir.buffer.Buffer"><span class="pre">Buffer</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../tir/tir.html#tvm.tir.IndexMap" title="tvm.tir.function.IndexMap"><span class="pre">IndexMap</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.suggest_layout_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Suggest Layout transformations of blocks and buffers in a PrimFunc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> (<a class="reference internal" href="#tvm.relax.analysis.PrimFunc" title="tvm.relax.analysis.PrimFunc"><em>PrimFunc</em></a>) – PrimFunc on which analysis will be performed and transformations suggested.</p></li>
<li><p><strong>write_buffer_transforms</strong> (<em>List</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap"><em>IndexMap</em></a><em>, </em><em>Callable</em><em>]</em>) – List of layout transformations on the output buffers. The number of layout
transformations must match the number of outputs of the PrimFunc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – Suggested transforms per block in <cite>func</cite>. For each block the returned value is a map
from the object (block or buffer) to it’s index map transformation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[<a class="reference internal" href="#tvm.relax.analysis.Block" title="tvm.relax.analysis.Block">Block</a>, Dict[Union[<a class="reference internal" href="#tvm.relax.analysis.Block" title="tvm.relax.analysis.Block">Block</a>, <a class="reference internal" href="#tvm.relax.analysis.Buffer" title="tvm.relax.analysis.Buffer">Buffer</a>], <a class="reference internal" href="#tvm.relax.analysis.IndexMap" title="tvm.relax.analysis.IndexMap">IndexMap</a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.tir_vars_in_struct_info">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">tir_vars_in_struct_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sinfo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="op.html#tvm.relax.op.StructInfo" title="tvm.relax.expr.StructInfo"><span class="pre">StructInfo</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.tir_vars_in_struct_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the TIR variables that appear in the input struct info.
The returned list is deduplicated - each TIR variable will appear at most once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sinfo</strong> (<a class="reference internal" href="#tvm.relax.analysis.StructInfo" title="tvm.relax.analysis.StructInfo"><em>StructInfo</em></a>) – The struct info object to be analyzed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – The list of TIR variables that appear in the input struct info.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="../tir/tir.html#tvm.tir.Var" title="tvm.tir.Var">tir.Var</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.udchain">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">udchain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dfb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.DataflowBlock" title="tvm.relax.expr.DataflowBlock"><span class="pre">DataflowBlock</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="transform.html#tvm.relax.transform.Var" title="tvm.relax.expr.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#tvm.relax.analysis.udchain" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the variable use-def chain in a dataflow block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dfb</strong> (<a class="reference internal" href="#tvm.relax.analysis.DataflowBlock" title="tvm.relax.analysis.DataflowBlock"><em>DataflowBlock</em></a>) – The dataflow block to analyze</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A mapping from variable definition to its uses.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[relax.Var, List[relax.Var]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tvm.relax.analysis.well_formed">
<span class="sig-prename descclassname"><span class="pre">tvm.relax.analysis.</span></span><span class="sig-name descname"><span class="pre">well_formed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mod</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tvm.relax.analysis.IRModule" title="tvm.ir.module.IRModule"><span class="pre">IRModule</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_struct_info</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#tvm.relax.analysis.well_formed" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the IRModule is well formed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mod</strong> (<em>tvm.IRModule</em>) – The input IRModule.</p></li>
<li><p><strong>check_struct_info</strong> (<em>bool</em>) – A boolean flag indicating if the property “every Expr must
have defined structure info” will be checked.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ret</strong> – True if the IRModule is well formed, False if not.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default the structure info is always checked. It is only in test cases
where <cite>check_struct_info</cite> might be false, so that other well-formed requirements
will be well tested and will not be blocked by not having structure info.</p>
</div>
</dd></dl>

</section>


           </div>
           
          </div>
          

<footer>

    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="block_builder.html" class="btn btn-neutral float-right" title="tvm.relax.block_builder" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="relax.html" class="btn btn-neutral float-left" title="tvm.relax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>

<div id="button" class="backtop"><img src="../../../_static/img/right.svg" alt="backtop"/> </div>
<section class="footerSec">
    <div class="footerHeader">
      <div class="d-flex align-md-items-center justify-content-between flex-column flex-md-row">
        <div class="copywrite d-flex align-items-center">
          <h5 id="copy-right-info">© 2023 Apache Software Foundation | All rights reserved</h5>
        </div>
      </div>

    </div>

    <div>
      <div class="footernote">Copyright © 2023 The Apache Software Foundation. Apache TVM, Apache, the Apache feather, and the Apache TVM project logo are either trademarks or registered trademarks of the Apache Software Foundation.</div>
    </div>

</section>
</footer>
        </div>
      </div>

    </section>

  </div>
  

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  </body>
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>